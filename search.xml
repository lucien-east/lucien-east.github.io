<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Manjaro上安裝行列或其他中文輸入法 (fcitx + rime)</title>
    <url>/2021/07/22/Chinese-Input-Method-on-Manjaro/</url>
    <content><![CDATA[<p>每一次重新安裝好用來開發的Linux環境時，總會因為自己是使用較小眾的行列輸入法，常得在過程中的安裝和設定上掙扎許久...</p>
<p>以往這些紀錄都只會留存在我個人的
Evernote；受惠於網路甚多，現在決定開始把這些過程重新整理並分享給有需要的人</p>
<p>以下步驟也適用於倉頡、大易、速成、嘸蝦米等中文輸入法</p>
<span id="more"></span>
<h2 id="安裝fcitx相關package">安裝fcitx相關package</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S fcitx-im fcitx-chewing fcitx-table-extra fcitx-configtool fcitx-rime</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fcitx-im</code>: fcitx + fcitx-qt5
<ul>
<li>fcitx: flexible Xontext-aware Input tool with eXtension</li>
<li>fcitx-qt5: fcitx Qt5 IM module</li>
</ul></li>
<li><code>fcitx-chewing</code> : 注音輸入法</li>
<li><code>fcitx-table-extra</code> : 含行列, 倉頡,
大易，嘸蝦米等輸入法之宇碼表，其支援的字碼表細節可參考 <a
href="https://github.com/fcitx/fcitx5-table-extra">Fcitx5-table-extra</a></li>
<li><code>fcitx-configtool</code> : 安裝fcitx圖形管理工具</li>
<li><code>fcitx-rime</code> : 安裝rime
<ul>
<li>rime 為跨平台的中文輸入法框架</li>
</ul></li>
</ul>
<p>安裝完成後，重新登入或啟動就可以使用了</p>
<h2 id="若開機時無法自動啟動">若開機時無法自動啟動</h2>
<p>非 KDE
的使用者可能會碰到開機沒有自動啟動的狀況，可以根據自身系統任選以下其中一個檔案做修改來達成開機啟動</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ~/.xinitrc</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GTK_IM_MODULE=fcitx</span><br><span class="line"><span class="built_in">export</span> QT_IM_MODULE=fcitx</span><br><span class="line"><span class="built_in">export</span> XMOFIFIERS=@im=fcitx</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">fcitx &amp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> YOUR_WINDOWS_MANAGER</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ~/.xprofile</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GTK_IM_MODULE=fcitx</span><br><span class="line"><span class="built_in">export</span> QT_IM_MODULE=fcitx</span><br><span class="line"><span class="built_in">export</span> XMOFIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ~/.xsession</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GTK_IM_MODULE=fcitx</span><br><span class="line"><span class="built_in">export</span> QT_IM_MODULE=fcitx</span><br><span class="line"><span class="built_in">export</span> XMOFIFIERS=@im=fcitx</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">YOUR_WINDOWS_MANAGER</span><br></pre></td></tr></table></figure>
<h2 id="使用方式">使用方式</h2>
<ol type="1">
<li><p>右鍵點選 fcitx 的 Configure (在右下 icon 列或是直接在 Manjaro
application launcher 裡尋找)</p></li>
<li><p>按 + 來新增需要的輸入法</p></li>
<li><p>選擇需要新增的輸入法 (若環境預設為英文語系或其他，記得要先將 Only
Show Current Language 的勾勾點掉)</p></li>
<li><p>新增完畢後可使用 <code>ctrl</code>+<code>space</code>
來切換</p></li>
</ol>
]]></content>
      <categories>
        <category>Environment SetUp</category>
      </categories>
      <tags>
        <tag>Manjaro</tag>
        <tag>InputMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>fcitx 行列輸入法無法使用標點符號</title>
    <url>/2021/07/24/Chinese-Input-Method-on-Manjaro-II/</url>
    <content><![CDATA[<p>設定好 fcitx 的行列輸入法時，會發現有無法正常使用標點符號的問題 (i.e.
<code>W</code> + <code>2</code> 沒反應)</p>
<p>這部份需要更新 fcitx 的字碼表，來修改 <code>W</code> + <code>1</code>
~ <code>9</code> 的行為</p>
<span id="more"></span>
<h2 id="下載行列輸入法30字碼表">下載行列輸入法30字碼表</h2>
<p>下載更新後的 array30.mb (<a
href="https://drive.google.com/file/d/1fDcoUeD4uBa7KtgWA8f_Ayl3nQZzud6r/view?usp=sharing">GoogleDrive</a>
by <a
href="http://hyperrate.com/thread.php?tid=33369#33369">老刀</a>)</p>
<blockquote>
<p>若希望手動製作字碼表，可至官方下載字碼表原始檔 (<a
href="http://array30.sourceforge.net/files/ar30.cin">gcin字碼表</a>)，並將其修改成
fcitx 的字碼表，再使用 fcitx 工具 <code>fcitx-tools</code>
轉為需要的格式: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S fcitx-tools</span><br><span class="line">txt2mb array30.txt array30.mb  <span class="comment"># Generate the table manually</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="更新字碼表">更新字碼表</h2>
<p>建議先將原來的字碼表做備份後，再將準備好的字碼表搬入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mv /usr/share/fcitx/table/array30.mb /usr/share/fcitx/table/array30.mb.bak  <span class="comment"># Backup</span></span><br><span class="line">sudo mv array30.mb /usr/share/fcitx/table/array30.mb</span><br></pre></td></tr></table></figure>
<h2 id="修改-fcitx-裡候選字數的設定">修改 fcitx 裡候選字數的設定</h2>
<p>這一步是為了讓配置和 Windows 一樣，將 fcitx 針對候選字數的設定變更為
10</p>
<ol type="1">
<li>進入 fcitx 的設定 (Configure)</li>
<li>切至全域設定 (Global Config)</li>
<li>更新候選字數 (Candidate Word Number) 為 10</li>
</ol>
<p>重新啟動 fcitx
或重新登入系統以載入新的字碼表就可以使用標點符號了，預設是使用
<code>↑</code> 和 <code>↓</code> 來切換上下頁</p>
]]></content>
      <categories>
        <category>Environment SetUp</category>
      </categories>
      <tags>
        <tag>Manjaro</tag>
        <tag>InputMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>Using Python to Simulate Brownian Motion</title>
    <url>/2021/07/27/Brownian-motion/</url>
    <content><![CDATA[<p><strong>Brownian motion</strong> is a phenomenon that particles in
the seemingly motionless liquid are still undergone unceasing collisions
in an erratic way. It was firstly observed by Robert Brown in 1827. In
1923, Norbert Wiener had attempted to formulate this observations in
mathematical terms; thus it is also known as <strong>Wiener
process</strong>.</p>
<p>Owing to its randomness, Brownian motion has a wide range of
applications, ranging from chaotic oscillations to stock market
fluctuations. In this article, I will describe its basic property and
how to visualise it and its variants with Python.</p>
<span id="more"></span>
<h2 id="The-Model-of-Brownian-Motion">The Model of Brownian Motion</h2>
<p>To begin with, we should see how to make Brownian motion in a rather
formal way.</p>
<p>We firstly consider one dimensional coordinate system for simplicity.
Imagine that you put a particle at the origin (<span
class="math inline">\(x = 0\)</span>) in the very beginning, and it may
encounter random collisions along the <span
class="math inline">\(x\)</span>-coordinate afterwards. Let <span
class="math inline">\(X(t)\)</span> be the position of the particle
after <span class="math inline">\(t\)</span> units of time (<span
class="math inline">\(X(0) = 0\)</span>).</p>
<p>When the particle is undergone some collisions, we say there are
events occurred. From physical obervations, scientists find that the
probability of events occurred in any two equal time intervals, say
<span class="math inline">\([s, t]\)</span> and <span
class="math inline">\([s+h, t+h]\)</span>, are not only equal but also
indepedent. In other words, they have the same probability distribution,
and no matter how many events occurred in <span
class="math inline">\([s, t]\)</span>, it would not affect the number of
events occurred over <span class="math inline">\([s+h, t+h]\)</span>.
This can be represented as</p>
<p><span class="math display">\[ X(t) - X(s) \sim X(t+h) - X(s+h)
\]</span></p>
<p>Actually, such property that they possess stationary and independent
increments are usually called <strong>stationary increments</strong>.
This is the bedrock of Brownian motion.</p>
<p>Thus, if $ t_1- t_0 = t_2-t_1 = t_3-t_2 = t_4-t_3 = $ ... ,</p>
<p><span class="math display">\[  X(t_1)-X(t_0)
\sim X(t_2)-X(t_1)
\sim X(t_3)-X(t_2)
\sim X(t_4)-X(t_3)
\dots  
\tag{1}
\]</span></p>
<p>For <span class="math inline">\(t&gt;s&gt;0\)</span>, we tend to
assume increments are normal distribution:</p>
<p><span class="math display">\[ X(t+s) - X(s) \sim \mathcal{N} (0,
\sigma^2 t) \tag{2}\]</span></p>
<p>If  $ \sigma = 1, $  it is also known as a <strong>standard Brownian
motion</strong>, $ W(t) $.</p>
<p>It is worth noting that the path of Brownian motion is <em>everywhere
continuous but nowhere differentiable</em>.</p>
<h2 id="visualise-the-brownian-motion">Visualise the Brownian
Motion</h2>
<p>Now we are ready to draw our Brownian motion in Python.</p>
<h3 id="some-toolkits">Some Toolkits</h3>
<p>Below are the modules we will use to draw our plots.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt, exp</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random, gauss</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<h3 id="visualisation">Visualisation</h3>
<p>As shown in <span class="math inline">\((1)\)</span> and <span
class="math inline">\((2),\)</span> the increments between any equal
time interval share the same Gaussian distribution. We are able to
compute <span class="math inline">\(X(t)\)</span> iteratively, i.e.</p>

$$
\displaylines {
X(t_1) \sim X(t_0) + \mathcal{N} (0, dt \cdot \sigma^2) \\
X(t_2) \sim X(t_1) + \mathcal{N} (0, dt \cdot \sigma^2) \\
X(t_3) \sim X(t_2) + \mathcal{N} (0, dt \cdot \sigma^2) \\
\dots  
}
$$

<p>, where $ dt = t_1-t_0 = t_2-t_1 = t_3-t_2 = $ ... .</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mean = <span class="number">0</span></span><br><span class="line">std = random()  <span class="comment"># standard deviation</span></span><br><span class="line"></span><br><span class="line">N = <span class="number">1000</span>    <span class="comment"># generate N points</span></span><br><span class="line">dt = <span class="number">1</span>/N    <span class="comment"># time interval = [0,1]</span></span><br><span class="line"></span><br><span class="line">data = []</span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    dx = gauss(mean, std*sqrt(dt))  <span class="comment"># gauss(mean, standard deviation)</span></span><br><span class="line">    x = x + dx                      <span class="comment"># compute X(t) incrementally</span></span><br><span class="line">    data.append((dt*t, x+dx))</span><br><span class="line"></span><br><span class="line">data = np.array(data)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(data[:, <span class="number">0</span>], data[:, <span class="number">1</span>], linewidth=<span class="number">0.5</span>)</span><br><span class="line">plt.scatter(data[<span class="number">0</span>, <span class="number">0</span>], data[<span class="number">0</span>, <span class="number">1</span>],marker=<span class="string">&quot;^&quot;</span>,color=<span class="string">&#x27;r&#x27;</span>,label=<span class="string">&quot;Origin&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.title(<span class="string">&quot;Brownian motion&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/2021/07/27/Brownian-motion/brownian.png" class="" title="This is an image">
<h2 id="d-brownian-motion">2D-Brownian Motion</h2>
<p>Similarly, if we extend our coordinate system to two dimensions,</p>

$$
\displaylines {
X(t_1) \sim X(t_0) + \mathcal{N} (0, dt \cdot \sigma^2) \; \; \; \; \; 
Y(t_1) \sim Y(t_0) + \mathcal{N} (0, dt \cdot \sigma^2) \\
X(t_2) \sim X(t_1) + \mathcal{N} (0, dt \cdot \sigma^2) \; \; \; \; \; 
Y(t_2) \sim Y(t_1) + \mathcal{N} (0, dt \cdot \sigma^2) \\
X(t_3) \sim X(t_2) + \mathcal{N} (0, dt \cdot \sigma^2) \; \; \; \; \; 
Y(t_3) \sim Y(t_2) + \mathcal{N} (0, dt \cdot \sigma^2) \\
\dots  
}
$$

<p>, where $ dt = t_1-t_0 = t_2-t_1 = t_3-t_2 = $ ... .</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mean = <span class="number">0</span></span><br><span class="line">std = random()</span><br><span class="line"></span><br><span class="line">N = <span class="number">1000</span>    <span class="comment"># generate N points</span></span><br><span class="line">dt = <span class="number">1</span>/N    <span class="comment"># time interval = [0,1]</span></span><br><span class="line"></span><br><span class="line">data = []</span><br><span class="line">x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    dx = gauss(mean, std*sqrt(dt))</span><br><span class="line">    dy = gauss(mean, std*sqrt(dt))</span><br><span class="line">    x, y = x+dx, y+dy</span><br><span class="line">    data.append((x, y))</span><br><span class="line"></span><br><span class="line">data = np.array(data)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(data[:, <span class="number">0</span>], data[:, <span class="number">1</span>], linewidth=<span class="number">0.5</span>)</span><br><span class="line">plt.scatter(data[<span class="number">0</span>, <span class="number">0</span>], data[<span class="number">0</span>, <span class="number">1</span>],marker=<span class="string">&quot;^&quot;</span>,color=<span class="string">&#x27;r&#x27;</span>,label=<span class="string">&quot;Origin&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.title(<span class="string">&quot;2D-Brownian motion&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/2021/07/27/Brownian-motion/brownian_2d.png" class="" title="This is an image">
<h2 id="d-brownian-motion-1">3D-Brownian Motion</h2>
<p>The Brownian motion over 3-dim coordinate system is also trivial when
you grasp the idea.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mean = <span class="number">0</span></span><br><span class="line">std = random()  <span class="comment"># standard deviation</span></span><br><span class="line"></span><br><span class="line">N = <span class="number">1000</span>    <span class="comment"># generate N points</span></span><br><span class="line">dt = <span class="number">1</span>/N    <span class="comment"># time interval = [0,1]</span></span><br><span class="line"></span><br><span class="line">data = []</span><br><span class="line">x, y, z = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    dx = gauss(mean, std*sqrt(dt))</span><br><span class="line">    dy = gauss(mean, std*sqrt(dt))</span><br><span class="line">    dz = gauss(mean, std*sqrt(dt))</span><br><span class="line">    x, y, z = x+dx, y+dy, z+dz</span><br><span class="line">    data.append((x, y, z))</span><br><span class="line"></span><br><span class="line">data = np.array(data)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">ax = plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">ax.plot3D(data[:, <span class="number">0</span>], data[:, <span class="number">1</span>], data[:, <span class="number">2</span>], linewidth=<span class="number">0.5</span>)</span><br><span class="line">ax.plot3D(data[<span class="number">0</span>, <span class="number">0</span>], data[<span class="number">0</span>, <span class="number">1</span>], data[<span class="number">0</span>, <span class="number">2</span>], marker=<span class="string">&#x27;^&#x27;</span>, color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;3D-Brownian motion&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/2021/07/27/Brownian-motion/brownian_3d.png" class="" title="This is an image">
<h2 id="geometric-brownian-motion">Geometric Brownian Motion</h2>
<p>In finance, random fluctuations are quite common in stock prices or
other derivatives and assets. To build the mathematical model upon the
Brownian motion, we need to make a few tweaks because such prices would
never be negative. A simple approach to tackling this is that we could
assume the trend follows exponential growth or decay curves in the long
run:</p>
<p><span class="math display">\[ S(t) = s_0 \cdot e^{X(t)} = s_0 \cdot
e^{\mu t + \sigma W(t)} \]</span></p>
<p>, where <span class="math inline">\(S(t)\)</span> is the stock price
at time <span class="math inline">\(t\)</span> and <span
class="math inline">\(s_0\)</span> is the initial price. We use
 
$ X(t) = \mu t + \sigma W(t) $ 
 with drift parameter <span
class="math inline">\(\mu\)</span> and <span
class="math inline">\(W(t)\)</span> : the standard Brownian motion.
Clearly, $ S(0) = s_0 $. The drift parameter can decide the trend for
this model, whereas <span class="math inline">\(\sigma\)</span> implies
the degree of unpredictability. This type of process is usually called
<strong>exponential Brownian motion</strong> or <strong>geometric
Brownian motion</strong>.</p>
<h3 id="the-relationship-between-stock-prices-at-time-t">The
Relationship between Stock Prices at Time <span
class="math inline">\(t\)</span></h3>
<p>As the model is established, we can observe the increments now lies
in the ratio change</p>
<p><span class="math display">\[
\frac{S(t_i)}{S(t_{i-1})}  =
e^{\mu(t_i - t_{i-1})} \cdot e^{\sigma [W(t_i) - W(t_{i-1}) ] }
\]</span></p>
<p>Therefore,</p>
<p><span class="math display">\[
\frac{S(t_1)}{S(t_0)} \sim
\frac{S(t_2)}{S(t_1)} \sim
\frac{S(t_3)}{S(t_2)}
\dots
\]</span></p>
<p>, where $ dt = t_1-t_0 = t_2-t_1 = t_3-t_2 = $ ... .</p>
<p>Below are a simple simulation of stock prices over the trading days
in a year, with its initial at $10.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mean = random()</span><br><span class="line">std = random()</span><br><span class="line"></span><br><span class="line">N = <span class="number">253</span>     <span class="comment"># trading days in a year</span></span><br><span class="line">dt = <span class="number">1</span>/N</span><br><span class="line"></span><br><span class="line">x = <span class="number">10.0</span>    <span class="comment"># initial stock price</span></span><br><span class="line">data = [(<span class="number">0</span>, x)]</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N):</span><br><span class="line">    ratio = exp(mean*dt) * exp(std * gauss(<span class="number">0</span>, sqrt(dt)))</span><br><span class="line">    x = x * ratio</span><br><span class="line">    data.append((dt*t, x))</span><br><span class="line"></span><br><span class="line">data = np.array(data)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(data[:, <span class="number">0</span>], data[:, <span class="number">1</span>], linewidth=<span class="number">0.5</span>)</span><br><span class="line">plt.plot(data[<span class="number">0</span>, <span class="number">0</span>], data[<span class="number">0</span>, <span class="number">1</span>], marker=<span class="string">&#x27;^&#x27;</span>, color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;price&#x27;</span>)</span><br><span class="line">plt.ylim([<span class="number">0</span>, <span class="built_in">max</span>(data[:,<span class="number">1</span>]+<span class="number">10</span>)])</span><br><span class="line">plt.title(<span class="string">&quot;Geometric Brownian motion&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/2021/07/27/Brownian-motion/brownian_geo.png" class="" title="This is an image">
]]></content>
      <categories>
        <category>Mathematics</category>
        <category>Probability and Statistics</category>
      </categories>
      <tags>
        <tag>Stochastic Process</tag>
        <tag>Brownian Motion</tag>
        <tag>Simulation</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>[C++] Optimise the Efficiency when Using STL Containers - taking vector emplace_back as an example</title>
    <url>/2021/07/29/cpp-vector-emplace/</url>
    <content><![CDATA[<p>C++ provides a plethora of containers that allow us to dynamically
allocate our elements in run time. Take <code>vector</code> as an
example. It is widely used in many applications. However, for some
extreme cases, we may still want to avoid the overhead of reallocation
or copy operations when those operations are quite expensive.</p>
<p>Since C++11, with the advent of <code>emplace</code> methods,
developers are able to pursue more efficiency via them.</p>
<span id="more"></span>
<h2 id="a-toy-example">A Toy Example</h2>
<p>To get a grasp of the usage of <code>emplace</code> , let's firstly
look at a simple object. Say we have a class containing the information
of a stock:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stock</span>(string date, <span class="keyword">double</span> price, <span class="keyword">int</span> volume) :</span><br><span class="line">        <span class="built_in">date</span>(date), <span class="built_in">price</span>(price), <span class="built_in">volume</span>(volume)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Contruct: &quot;</span> &lt;&lt; date &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Stock</span>(<span class="keyword">const</span> Stock&amp; obj) :</span><br><span class="line">        <span class="built_in">date</span>(obj.date), <span class="built_in">price</span>(obj.price), <span class="built_in">volume</span>(obj.volume)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copied: &quot;</span> &lt;&lt; date &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string date;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">int</span> volume;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>For the convenience of observation, when the object is created or
copied, the corresponded message will be printed.</p>
<h2 id="the-behavior-of-copy-between-push_back-and-emplace_back">The
Behavior of Copy between <code>push_back</code> and
<code>emplace_back</code></h2>
<p>We now use a vector - <code>portfolio</code> - to maintain our stock
objects.</p>
<p>First, we add the object <code>2021-08-01</code> into it via
<code>push_back()</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Stock&gt; portfolio;</span><br><span class="line">    portfolio.<span class="built_in">push_back</span>(&#123;<span class="string">&quot;2021-08-01&quot;</span>, <span class="number">10.0</span>, <span class="number">3</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When executing the program, we get the output:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Contruct: 2021-08-01</span><br><span class="line">Copied: 2021-08-01</span><br></pre></td></tr></table></figure>
<p>It shows that this object is created and copied into the vector
afterwards. The copy occurs for the reason that our object is not
allocated on the space where our vector <code>portfolio</code> is
located. The system still has to copy it onto the vector space.</p>
<p>This copy operation can be spared if our system can simply construct
our object onto <code>portfolio</code>'s space. The method
<code>emplace_back()</code> can come into play:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;Stock&gt; portfolio;</span><br><span class="line">portfolio.<span class="built_in">emplace_back</span>(<span class="string">&quot;2021-08-01&quot;</span>, <span class="number">10.0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>When executing the program, the copy operation has disappeared. The
object now is constructed in place:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Contruct: 2021-08-01</span><br></pre></td></tr></table></figure>
<p>Note the syntax sugar only needs us to specify our arguments: <a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span> <span class="params">(Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="another-unexpected-copy-behind-the-background">Another
Unexpected Copy behind the Background</h2>
<p>Cautious readers would find that if we add more items, there might be
still copy occurring:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;Stock&gt; portfolio;</span><br><span class="line">portfolio.<span class="built_in">emplace_back</span>(<span class="string">&quot;2021-08-01&quot;</span>, <span class="number">10.0</span>, <span class="number">3</span>);</span><br><span class="line">portfolio.<span class="built_in">emplace_back</span>(<span class="string">&quot;2021-08-02&quot;</span>, <span class="number">12.5</span>, <span class="number">5</span>);</span><br><span class="line">portfolio.<span class="built_in">emplace_back</span>(<span class="string">&quot;2021-08-03&quot;</span>, <span class="number">15.7</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>Its output:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Contruct: 2021-08-01</span><br><span class="line">Contruct: 2021-08-02</span><br><span class="line">Copied: 2021-08-01</span><br><span class="line">Contruct: 2021-08-03</span><br><span class="line">Copied: 2021-08-01</span><br><span class="line">Copied: 2021-08-02</span><br></pre></td></tr></table></figure>
<p>To understand this, we have to know that the <strong>storage
space</strong> of a vector ought to be allocated in advance. Do not
confuse this storage space with the <strong>actual size</strong> used by
the user (indicated by <code>size()</code>). The storage space is always
equal or greater than the atual size of a vector, so that our system
need not reallocate on each insertion. The size of the storage space can
be obtained by the method <code>capacity()</code>.</p>
<p>Now we are able to analyse this behavior with the help of it:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;Stock&gt; portfolio;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Capacity before inserting 2021-08-01 = &quot;</span> &lt;&lt; portfolio.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">portfolio.<span class="built_in">emplace_back</span>(<span class="string">&quot;2021-08-01&quot;</span>, <span class="number">10.0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Capacity before inserting 2021-08-02 = &quot;</span> &lt;&lt; portfolio.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">portfolio.<span class="built_in">emplace_back</span>(<span class="string">&quot;2021-08-02&quot;</span>, <span class="number">12.5</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Capacity before inserting 2021-08-03 = &quot;</span> &lt;&lt; portfolio.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">portfolio.<span class="built_in">emplace_back</span>(<span class="string">&quot;2021-08-03&quot;</span>, <span class="number">15.7</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Capacity before inserting 2021-08-01 = 0</span><br><span class="line">Contruct: 2021-08-01</span><br><span class="line"></span><br><span class="line">Capacity before inserting 2021-08-02 = 1</span><br><span class="line">Contruct: 2021-08-02</span><br><span class="line">Copied: 2021-08-01</span><br><span class="line"></span><br><span class="line">Capacity before inserting 2021-08-03 = 2</span><br><span class="line">Contruct: 2021-08-03</span><br><span class="line">Copied: 2021-08-01</span><br><span class="line">Copied: 2021-08-02</span><br></pre></td></tr></table></figure>
<p>When <code>2021-08-01</code> is constructed, it just allocates in
place, no copy is needed as aforementioned.</p>
<p>However, when adding <code>2021-08-02</code>, the acutual size of a
vector now grows to 2, the storage space is not enough to accomodate.
Thus, the system has to reallocate its storage space in advance, then
<strong>constructing</strong> <code>2021-08-02</code> on it, followed by
<strong>copying</strong> the <code>2021-08-01</code> objects into the
newly allocated space.</p>
<p>Similarly, <code>2021-08-03</code> is <strong>constructed in
place</strong> before the system allocates enough storage space.
Then,<code>2021-08-01</code> and <code>2021-08-02</code> will be
<strong>copied</strong> into the reallocated space afterwards.</p>
<blockquote>
<p>Note the elements in a vector are stored in a <strong>contiguous
memory block</strong>.<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a> This is the reason that when there
is no enough storage space for insertion, the system has to reallocate a
memory block to arrange its elements. The behavior of how capacity will
grow may vary by different system.</p>
</blockquote>
<h2 id="the-usage-of-reserve">The Usage of <code>reserve</code></h2>
<p>To optimise this, we could have our vector contain enough storage
space in advance. This is the moment when the method
<code>reserve()</code> can take advantage:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;Stock&gt; portfolio;</span><br><span class="line"></span><br><span class="line">portfolio.<span class="built_in">reserve</span>(<span class="number">5</span>);   <span class="comment">// Request enough storage space</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Capacity before inserting 2021-08-01 = &quot;</span> &lt;&lt; portfolio.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">portfolio.<span class="built_in">emplace_back</span>(<span class="string">&quot;2021-08-01&quot;</span>, <span class="number">10.0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Capacity before inserting 2021-08-02 = &quot;</span> &lt;&lt; portfolio.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">portfolio.<span class="built_in">emplace_back</span>(<span class="string">&quot;2021-08-02&quot;</span>, <span class="number">12.5</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Capacity before inserting 2021-08-03 = &quot;</span> &lt;&lt; portfolio.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">portfolio.<span class="built_in">emplace_back</span>(<span class="string">&quot;2021-08-03&quot;</span>, <span class="number">15.7</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Capacity before inserting 2021-08-01 = 5</span><br><span class="line">Contruct: 2021-08-01</span><br><span class="line"></span><br><span class="line">Capacity before inserting 2021-08-02 = 5</span><br><span class="line">Contruct: 2021-08-02</span><br><span class="line"></span><br><span class="line">Capacity before inserting 2021-08-03 = 5</span><br><span class="line">Contruct: 2021-08-03</span><br></pre></td></tr></table></figure>
<p>The copy operations has disappeared if the storage size are large
enough. Remember that <code>reserve()</code> does not cause any effect
on the vector size.</p>
<blockquote>
<p>The maximum capacity of a vector is restricted by
<code>vector::max_size</code>.</p>
</blockquote>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="https://www.cplusplus.com/reference/vector/vector/emplace_back/">C++
Reference - std::vector::emplace_back</a><a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a
href="https://timsong-cpp.github.io/cppwp/n4140/vector.overview#1">C++
Standard n4140: Class template vector overview</a><a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>Programming Language</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Optimisation</tag>
      </tags>
  </entry>
  <entry>
    <title>[C++] Smart Pointers - unique_ptr, shared_ptr, weak_ptr - from the implementation to their usage</title>
    <url>/2021/08/07/cpp-smart-pointers/</url>
    <content><![CDATA[<p>When we develop our program or the system continues to grow as time
goes by, <strong>memory leakage</strong> is usually a pain we suffer
most. To militate against this problem, C++ has introduced smart pointer
family - <code>unique_ptr</code>, <code>shared_ptr</code>,
<code>weak_ptr</code>, defined in header <code>&lt;memory&gt;</code>,
since C++11.</p>
<blockquote>
<p>Precisely, <code>unique_ptr</code> inherits most of characteristics
from <code>auto_ptr</code>, which has been implemented since C++03. Yet,
due to the lack of <code>move</code> semantics, it encounters
significant limitation: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line">vector&lt;auto_ptr&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line">vec.<span class="built_in">push_back</span>(p);            <span class="comment">// !!! error, because of Copy constructor</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(p))  <span class="comment">// Okay, with move semantics since C++11</span></span><br></pre></td></tr></table></figure> Note that <code>auto_ptr</code> is
<strong>deprecated</strong> now and should not be used any more for
safety.</p>
</blockquote>
<span id="more"></span>
<h2 id="a-toy-example">A Toy Example</h2>
<p>Let's use a simple example to illustrate how these smart pointers
work:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Obj</span> () : <span class="built_in">name</span>(<span class="string">&quot;DEFAULT&quot;</span>)  &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Construct &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Obj</span> (string name) : <span class="built_in">name</span>(name) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Construct &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\n&quot;</span>;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Obj</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Hi &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>When the object is created or released, the corresponded message will
be printed.</p>
<h2 id="original-way-with-new-and-delete">Original Way with
<code>new</code> and <code>delete</code></h2>
<p>Before utilising smart pointers, developers who want to allocate a
new object might write the below code:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Obj* p0 = <span class="keyword">new</span> <span class="built_in">Obj</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">delete</span> p0;  <span class="comment">// forgetting this would lead to memory leak</span></span><br></pre></td></tr></table></figure>
<p>We have to carefully ensure the created object will be released
before leaving the procedure; otherwise leading to memory leakage.
However, relying on smart pointers, the system is able to automatically
destroy the allocated object based upon whether it is owned by any
pointer.</p>
<h2 id="unique_ptr"><code>unique_ptr</code></h2>
<p><code>unique_ptr</code>, as its name suggests, owns an object
uniquely. That means you cannot have the same memory owned by two or
more <code>unique_ptr</code> objects; thus, it is also <strong>not
copyable</strong>. When the <code>unique_ptr</code> goes out of scope,
its holding object will be destroyed immediately.</p>
<h3 id="code-snippet-from-stdunique_ptr">Code Snippet from
<code>std::unique_ptr</code></h3>
<p>The implementation of <code>unique_ptr</code> in libstdc++ is worth
mentioning for clarity (I have omitted the detail):<a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp = default_delete&lt;_Tp&gt;&gt;</span><br><span class="line">class unique_ptr</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before move from rvalue,</span></span><br><span class="line">    <span class="comment">// releasing the ownership of the managed object if it owns a pointer</span></span><br><span class="line">    unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">reset</span>(__u.<span class="built_in">release</span>());</span><br><span class="line">        <span class="built_in">get_deleter</span>() = std::forward&lt;_Ep&gt;(__u.<span class="built_in">get_deleter</span>());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destroy the object if necessary, equivalent to reset()</span></span><br><span class="line">    unique_ptr&amp; <span class="keyword">operator</span>=(<span class="keyword">nullptr_t</span>) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// _M_t stores the data of this unique_ptr object</span></span><br><span class="line">        <span class="built_in">reset</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release the ownership of any stored pointer,</span></span><br><span class="line">    <span class="comment">// and return the pointer to the managed object</span></span><br><span class="line">    <span class="function">pointer <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// _M_t stores the data of the managed object</span></span><br><span class="line">        <span class="keyword">return</span> _M_t.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destroy the object if necessary</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(pointer __p = pointer())</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// _M_t stores the data of the managed object</span></span><br><span class="line">        _M_t.<span class="built_in">reset</span>(std::<span class="built_in">move</span>(__p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disable copy from lvalue.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>(<span class="keyword">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    unique_ptr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Briefly, <code>unique_ptr</code> will release the current holding
memory if necessary. Moreover, its copy constructor and copy assignment
are disabled.</p>
<h3 id="example-1-unique_ptr-is-unique-and-not-copyable">Example 1:
<code>unique_ptr</code> is unique and not copyable</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// unique_ptr&lt;Obj&gt; p1 (new Obj(&quot;1&quot;));           // This is okay</span></span><br><span class="line">    <span class="function">unique_ptr&lt;Obj&gt; <span class="title">p1</span> <span class="params">(make_unique&lt;Obj&gt;(<span class="string">&quot;1&quot;</span>))</span></span>;     <span class="comment">// Recommend since C++14</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// unique_ptr&lt;Obj&gt; p2 = p1;    // ! error, not copyable</span></span><br><span class="line">    p1-&gt;<span class="built_in">SayHi</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&lt;&lt;... END ...&gt;&gt;\n\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Construct 1</span><br><span class="line">Hi 1!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&lt;... END ...&gt;&gt;</span><br><span class="line"></span><br><span class="line">Destroy 1</span><br></pre></td></tr></table></figure></p>
<p>The allocated space held by <code>p1</code> is released automatically
when its lifetime ends.</p>
<blockquote>
<p><a href="#The-advantages-of-make_unique">It is recommended to use
<code>make_unique</code> to create <code>unique_ptr</code>
objects.</a></p>
</blockquote>
<h3
id="example-2-original-holding-object-will-be-destroyed-before-setting-to-null">Example
2: original holding object will be destroyed before setting to null</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;Obj&gt; <span class="title">p1</span> <span class="params">(make_unique&lt;Obj&gt;(<span class="string">&quot;1&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    p1-&gt;<span class="built_in">SayHi</span>();</span><br><span class="line"></span><br><span class="line">    p1 = <span class="literal">nullptr</span>;           <span class="comment">// Okay, destroy 1 before setting to null</span></span><br><span class="line">    <span class="comment">// p1.reset(nullptr);   // Same result</span></span><br><span class="line">    <span class="comment">// p1.reset();          // Same result</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&lt;&lt;... END ...&gt;&gt;\n\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Construct 1</span><br><span class="line">Hi 1!</span><br><span class="line">Destroy 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&lt;... END ...&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>p1</code> has been destroyed before setting it as null. Using
the method <code>reset()</code> can achieve the same result as well.</p>
<h3
id="example-3-original-holding-object-will-be-destroyed-before-move-assignment">Example
3: original holding object will be destroyed before move assignment</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;Obj&gt; <span class="title">p1</span> <span class="params">(make_unique&lt;Obj&gt;(<span class="string">&quot;1&quot;</span>))</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;Obj&gt; <span class="title">p2</span> <span class="params">(make_unique&lt;Obj&gt;(<span class="string">&quot;2&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    p2 = std::<span class="built_in">move</span>(p1);          <span class="comment">// Okay, destroy 2 before move</span></span><br><span class="line">    <span class="comment">// p2.reset(p1.release());   // Same result, release the p1 ownership, then move to p2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// p1-&gt;SayHi();     // ! error, p1 no longer valid</span></span><br><span class="line">    p2-&gt;<span class="built_in">SayHi</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&lt;&lt;... END ...&gt;&gt;\n\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Construct 1</span><br><span class="line">Construct 2</span><br><span class="line">Destroy 2</span><br><span class="line">Hi 1!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&lt;... END ...&gt;&gt;</span><br><span class="line"></span><br><span class="line">Destroy 1</span><br></pre></td></tr></table></figure>
<p>Object <code>2</code> has been destroyed while moving object
<code>1</code> into <code>p2</code>. Note that you have to release the
ownership of object <code>1</code> with <code>release()</code> firstly
before assigning it to the next owner.</p>
<h2 id="The-advantages-of-make_unique">The Advantages of
<code>make_unique</code> over <code>new</code> operator</h2>
<p><code>make_unique</code> has been introduced since C++14, and its
implementation can be briefly rewritten as:<a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="comment">// for single objects</span></span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;!std::is_array&lt;T&gt;::value, std::unique_ptr&lt;T&gt;&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">make_unique</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> unique_ptr&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For the most part, it makes no difference between either
<code>new</code> or <code>make_unique</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>));</span><br><span class="line">make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);   <span class="comment">// no difference</span></span><br></pre></td></tr></table></figure>
<p>However, the former may go awry if it involves several arguments
evaluation in a function call:<a href="#fn3" class="footnote-ref"
id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">func</span>(unique_ptr&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>)), <span class="built_in">Foo</span>());  <span class="comment">// unsafe</span></span><br><span class="line"><span class="built_in">func</span>(make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>), <span class="built_in">Foo</span>());          <span class="comment">// exception safe</span></span><br></pre></td></tr></table></figure>
<p>Before C++17, the order of function arguments evaluation is not
defined.<a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a></p>
<p>Consider the evaluation sequence below:</p>
<ol type="1">
<li>Create <code>int (1)</code> object   <strong><em>--- Success !
</em></strong></li>
<li>Execute <code>Foo()</code>   <strong><em>--- Exception !
</em></strong></li>
<li>Assign the created <code>int (1)</code> to a <code>unique_ptr</code>
object   <strong><em>--- Cannot be performed ! </em></strong></li>
</ol>
<p>If <code>new</code> has been processed without assigning the newly
created object to <code>unique_ptr</code>, and exception happens in
<code>Foo()</code>, then memory leakage occurs because there is no way
for <code>unique_ptr</code> object to access the newly created object to
destroy it.</p>
<p>Therefore, when you would like to create <code>unique_ptr</code>
objects, <code>make_unique</code> is a better choice for exception
safety. Even though it is not introduced in C++11, defining it manually
is quite simple as aforementioned.</p>
<h2 id="construct-an-array-of-unique_ptr-objects">Construct an Array of
<code>unique_ptr</code> Objects</h2>
<p>There are two ways to construct an array of <code>unique_ptr</code>
objects as well.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// unique_ptr&lt;Obj []&gt; pArray (new Obj[3]());        // This is okay. Its size is 3</span></span><br><span class="line">    <span class="function">unique_ptr&lt;Obj[]&gt; <span class="title">pArray</span> <span class="params">(make_unique&lt;Obj[]&gt;(<span class="number">3</span>))</span></span>;   <span class="comment">// Recommend</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">        pArray[i].<span class="built_in">SayHi</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&lt;&lt;... END ...&gt;&gt;\n\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Construct DEFAULT</span><br><span class="line">Construct DEFAULT</span><br><span class="line">Construct DEFAULT</span><br><span class="line">Hi DEFAULT!</span><br><span class="line">Hi DEFAULT!</span><br><span class="line">Hi DEFAULT!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&lt;... END ...&gt;&gt;</span><br><span class="line"></span><br><span class="line">Destroy DEFAULT</span><br><span class="line">Destroy DEFAULT</span><br><span class="line">Destroy DEFAULT</span><br></pre></td></tr></table></figure></p>
<p>Compared to a single object, the parameter in
<code>make_unique</code> is <strong>the array size</strong> instead of
an initialiser.</p>
<p>Similar to the single object, its array version can be briefly
rewritten as:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// for array objects</span></span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_array&lt;T&gt;::value, std::unique_ptr&lt;T&gt;&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">make_unique</span><span class="params">(<span class="keyword">size_t</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unique_ptr&lt;T&gt;(<span class="keyword">new</span> <span class="keyword">typename</span> std::remove_extent&lt;T&gt;::type[num]());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note the subtle difference against a single object is the judgement
of <code>is_array&lt;T&gt;::value</code>.</p>
<h2 id="shared_ptr"><code>shared_ptr</code></h2>
<p>Unlike <code>unique_ptr</code>, the ownership of an object can be
shared by multiple <code>shared_ptr</code> objects. The object will be
destroyed once it is not owned by any <code>shared_ptr</code> objects.
This information can be obtained by the method
<code>use_count()</code></p>
<h3 id="code-snippet-from-stdshared_ptr">Code Snippet from
<code>std::shared_ptr</code></h3>
<p>The implementation of <code>shared_ptr</code> in libstdc++ is worth
mentioning for clarity (I have omitted the detail):<a href="#fn5"
class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span> :</span> <span class="keyword">public</span> __shared_ptr&lt;_Tp&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">weak_ptr</span>&lt;</span>_Tp&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>shared_ptr</code> inherits from <code>__shared_ptr</code>
class<a href="#fn6" class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a>, and you could observe
<code>weak_ptr</code> is able to access the private members in
<code>shared_ptr</code> objects. Actually, <code>shared_ptr</code> and
<code>weak_ptr</code> indeed cooperate together from time to time which
will be elaborated later.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">shared_ptr</span> :</span> <span class="keyword">public</span> __shared_ptr_access&lt;_Tp, _Lp&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Default constructor where its initial value of pointer </span></span><br><span class="line">    <span class="comment">// and reference count are null and 0</span></span><br><span class="line">    <span class="keyword">constexpr</span> __shared_ptr() <span class="keyword">noexcept</span></span><br><span class="line">    : _M_ptr(<span class="number">0</span>), _M_refcount()</span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If an exception is thrown this constructor has no effect.</span></span><br><span class="line">    <span class="comment">// _M_refcount will be assigned as a newly created object - __shared_count.</span></span><br><span class="line">    <span class="comment">// The count in __shared_count will be incremented</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Yp, <span class="keyword">typename</span> _Del, <span class="keyword">typename</span> = _UniqCompatible&lt;_Yp, _Del&gt;&gt;</span><br><span class="line">    __shared_ptr(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r) : _M_ptr(__r.<span class="built_in">get</span>()), _M_refcount()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> __raw = __to_address(__r.<span class="built_in">get</span>());</span><br><span class="line">        _M_refcount = __shared_count&lt;_Lp&gt;(std::<span class="built_in">move</span>(__r));</span><br><span class="line">        _M_enable_shared_from_this_with(__raw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Similar to the constructor, the count in __shared_count will be incremented</span></span><br><span class="line">    <span class="comment">// and the current object will be replaced with the new one</span></span><br><span class="line">    __shared_ptr&amp; <span class="keyword">operator</span>=(__shared_ptr&amp;&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        __shared_ptr(std::<span class="built_in">move</span>(__r)).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Return the number of owners</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// _M_refcount is an object storing the reference counter information</span></span><br><span class="line">        <span class="keyword">return</span> _M_refcount._M_get_use_count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Construct a null shared ptr and and the current object will be replaced with it</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        __shared_ptr().<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Yp&gt;</span></span><br><span class="line"><span class="function">	_SafeConv&lt;_Yp&gt; <span class="title">reset</span><span class="params">(_Yp* __p)</span> <span class="comment">// _Yp must be complete.</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	  <span class="comment">// Catch self-reset errors.</span></span><br><span class="line">	  __glibcxx_assert(__p == <span class="number">0</span> || __p != _M_ptr);</span><br><span class="line">	  __shared_ptr(__p).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    element_type*        _M_ptr;         <span class="comment">// Contained pointer.</span></span><br><span class="line">    __shared_count&lt;_Lp&gt;  _M_refcount;    <span class="comment">// Reference counter.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Briefly, <code>shared_ptr</code> object records the number of owners
(<code>__shared_count</code>) as well as the pointer of the managed
object. Besides, <code>__shared_ptr_access</code>, the parent class,
defines whether this object should be accessed by array operators or
not.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">shared_count</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Increase the reference counter</span></span><br><span class="line">    __shared_count(<span class="keyword">const</span> __shared_count&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">    : _M_pi(__r._M_pi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_M_pi != <span class="number">0</span>)</span><br><span class="line">            _M_pi-&gt;_M_add_ref_copy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Increase the reference counter</span></span><br><span class="line">    __shared_count&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> __shared_count&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">        <span class="keyword">if</span> (__tmp != _M_pi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (__tmp != <span class="number">0</span>)</span><br><span class="line">                __tmp-&gt;_M_add_ref_copy();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_M_pi != <span class="number">0</span>)</span><br><span class="line">                _M_pi-&gt;_M_release();</span><br><span class="line"></span><br><span class="line">            _M_pi = __tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> __<span class="title">weak_count</span>&lt;</span>_Lp&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define the operations of the stored pointer</span></span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;*  _M_pi;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The <code>__shared_count</code> object is to manage the information
of reference count. Here, <code>__weak_count</code> class is able to
access the private members of <code>__shared_count</code>. Most of
operations on the pointer itself are specified in
<code>_Sp_counted_base</code>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp = __default_lock_policy&gt;</span><br><span class="line">class _Sp_counted_base : <span class="keyword">public</span> _Mutex_base&lt;_Lp&gt;&#123;  <span class="comment">/* ... */</span>  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Sp_counted_base&lt;_S_single&gt;::_M_release() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (--_M_use_count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// the managed object will be destroyed once it is not held by any shared_ptr</span></span><br><span class="line">        _M_dispose();</span><br><span class="line">        <span class="keyword">if</span> (--_M_weak_count == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// the control block is not released until its weak_ptr count reaches zero</span></span><br><span class="line">            _M_destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that while a <code>shared_ptr</code> object is created, the
lifetime of the managed object and its <strong>control block</strong>
might not be the same. The former is based upon whether it is shared by
any <code>shared_ptr</code> objects, whereas the later is
<code>weak_ptr</code>.</p>
<blockquote>
<p>Control block contains the information about how to allocate or
deallocate the managed object, e.g. its allocator and deleter.</p>
</blockquote>
<h3 id="example-1-several-shared_ptr-can-share-the-same-object">Example
1: several <code>shared_ptr</code> can share the same object</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// shared_ptr&lt;Obj&gt; sp0 (new Obj(&quot;1&quot;));           // Okay</span></span><br><span class="line">    shared_ptr&lt;Obj&gt; sp0 = make_shared&lt;Obj&gt;(<span class="string">&quot;1&quot;</span>);     <span class="comment">// Recommend</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;count = &quot;</span> &lt;&lt; sp0.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Obj&gt; sp1 = sp0;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;count = &quot;</span> &lt;&lt; sp0.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&lt;&lt;... END ...&gt;&gt;\n\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Construct 1</span><br><span class="line">count = 1</span><br><span class="line">count = 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&lt;... END ...&gt;&gt;</span><br><span class="line"></span><br><span class="line">Destroy 1</span><br></pre></td></tr></table></figure></p>
<p>Object <code>1</code> can be held by both <code>sp0</code> and
<code>sp1</code>. It is recommended to use <code>make_shared</code> to
create the smart pointer due to <a
href="#The-advantages-of-make_unique">the same reason explained in
<code>make_unique</code></a>.</p>
<h3
id="example-2-the-managed-object-will-be-destroyed-when-it-is-not-held-by-any-shared_ptr">Example
2: the managed object will be destroyed when it is not held by any
<code>shared_ptr</code></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr&lt;Obj&gt; sp2 = make_shared&lt;Obj&gt;(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    shared_ptr&lt;Obj&gt; sp3 = sp2;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;count = &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    sp3.<span class="built_in">reset</span>();        <span class="comment">// release the ownership from sp3</span></span><br><span class="line">    <span class="comment">//sp3 = nullptr;    // Same effect</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;count = &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    sp2.<span class="built_in">reset</span>();        <span class="comment">// the reference count of object 2 becomes 0, destroyed</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;count = &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&lt;&lt;... END ...&gt;&gt;\n\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Construct 2</span><br><span class="line">count = 2</span><br><span class="line">count = 1</span><br><span class="line">Destroy 2</span><br><span class="line">count = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&lt;... END ...&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>Object <code>2</code> is destroyed while its reference count becomes
0.</p>
<h2 id="construct-an-array-of-shared_ptr-objects">Construct an Array of
<code>shared_ptr</code> Objects</h2>
<p>Unlike <code>unique_ptr</code> objects, <code>shared_ptr</code>
cannot dynamically allocate an array via <code>make_shared</code> until
C++20. Moreover, prior to C++17, developers ought to specify the deleter
to manage dynamically allocated arrays.<a href="#fn7"
class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// suggest to provide a deleter for array</span></span><br><span class="line">    <span class="comment">// so it uses delete[] to free the resoure instead of delete</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Obj[]&gt; <span class="title">spArray</span> <span class="params">(<span class="keyword">new</span> Obj[<span class="number">3</span>], std::default_delete&lt;Obj[]&gt;())</span></span>;  <span class="comment">// Okay, </span></span><br><span class="line">    <span class="comment">//shared_ptr&lt;Obj[]&gt; spArray (make_shared&lt;Obj[]&gt;(3));  // Not available until C++20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">        spArray[i].<span class="built_in">SayHi</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&lt;&lt;... END ...&gt;&gt;\n\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Construct DEFAULT</span><br><span class="line">Construct DEFAULT</span><br><span class="line">Construct DEFAULT</span><br><span class="line">Hi DEFAULT!</span><br><span class="line">Hi DEFAULT!</span><br><span class="line">Hi DEFAULT!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&lt;... END ...&gt;&gt;</span><br><span class="line"></span><br><span class="line">Destroy DEFAULT</span><br><span class="line">Destroy DEFAULT</span><br><span class="line">Destroy DEFAULT</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Actually, it is worth mentioning that since GCC 7.5, a default
deleter to handle the dynamically allocated array has been provided by
<code>struct __sp_array_delete</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The default deleter for shared_ptr&lt;T[]&gt; and shared_ptr&lt;T[N]&gt;.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">sp_array_delete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Yp&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Yp* __p)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">delete</span>[] __p; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>It works as follows:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">shared_ptr</span> :</span> <span class="keyword">public</span> __shared_ptr_access&lt;_Tp, _Lp&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor will check whether it is an array</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Yp, <span class="keyword">typename</span> = _SafeConv&lt;_Yp&gt;&gt;</span><br><span class="line">    <span class="keyword">explicit</span></span><br><span class="line">    __shared_ptr(_Yp* __p)</span><br><span class="line">    : _M_ptr(__p), _M_refcount(__p, <span class="keyword">typename</span> is_array&lt;_Tp&gt;::<span class="built_in">type</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        _M_enable_shared_from_this_with(__p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The <code>__shared_ptr</code> constructor checks whether the managed
object is an array.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">shared_count</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ptr&gt;</span><br><span class="line">    __shared_count(_Ptr __p, <span class="comment">/* is_array = */</span> true_type)</span><br><span class="line">    : __shared_count(__p, __sp_array_delete&#123;&#125;, allocator&lt;<span class="keyword">void</span>&gt;())</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>If the pointer is an array, the default deleter will be designated as
<code>__sp_array_delete</code>.</p>
<p>Thus, the below code should work fine even if we do not provide a
deleter:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Obj[]&gt; <span class="title">spArray</span> <span class="params">(<span class="keyword">new</span> Obj[<span class="number">3</span>])</span></span>;  <span class="comment">// Okay if deleter is not provided</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>However, prior to C++17, we still suggest developers follow the rule
to avoid undefined behavior resulted from compiler dependency.</p>
</blockquote>
<h2 id="leakage-caused-by-circular-reference">Leakage caused by Circular
Reference within <code>shared_ptr</code></h2>
<p>Consider the case when you would like to implement list data
structure, the code might look like as follows:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    shared_ptr&lt;List&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">List</span>(<span class="keyword">int</span> val) : <span class="built_in">val</span>(val) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Construct node &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">List</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy node &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>And the list might form a cycle:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;List&gt; <span class="title">node_1</span> <span class="params">(make_shared&lt;List&gt;(<span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;List&gt; <span class="title">node_2</span> <span class="params">(make_shared&lt;List&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    node_1-&gt;next = node_2;</span><br><span class="line">    node_2-&gt;next = node_1;      <span class="comment">// A cycle is formed</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;count = &quot;</span> &lt;&lt; node_1.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&lt;&lt;... END ...&gt;&gt;\n\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Construct node 1</span><br><span class="line">Construct node 2</span><br><span class="line">count = 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&lt;... END ...&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>Under this circumstance, both <code>node 1</code> and
<code>node 2</code> are referenced to one another, the user count never
degrades to zero even when the program terminates, leading to memory
leakage. This problem is called <strong>circular reference</strong> or
<strong>cyclic dependency</strong> issue.</p>
<p>To solve this problem, <code>weak_ptr</code> could come into play,
which won't affect the reference count of an object. We may simply
modify our list structure as follows:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    weak_ptr&lt;List&gt; next;      <span class="comment">// weak reference</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">List</span>(<span class="keyword">int</span> val) : <span class="built_in">val</span>(val) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Construct node &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">List</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroy node &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Construct node 1</span><br><span class="line">Construct node 2</span><br><span class="line">count = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&lt;... END ...&gt;&gt;</span><br><span class="line"></span><br><span class="line">Destroy node 2</span><br><span class="line">Destroy node 1</span><br></pre></td></tr></table></figure></p>
<p>Now, with the help of <code>weak_ptr</code>, the reference count does
not increase for the reason that it is not considered an owner for this
object. The memory leakage issue can be prevented.</p>
<h2 id="weak_ptr"><code>weak_ptr</code></h2>
<p><code>weak_ptr</code> can hold a "weak" reference to an object, which
won't affect the reference count managed by <code>shared_ptr</code>. The
main aim of <code>weak_ptr</code> is to own a temporary ownership so we
can track this object. It is also an effective way to prevent <a
href="#leakage-caused-by-circular-reference">the memory leakage problem
caused by a cycle within <code>shared_ptr</code> objects</a>. In
addition to that, we should be aware that even when the object held by
<code>shared_ptr</code> is destroyed, the lifetime of its control block
might be extended. To access the referenced object of
<code>weak_ptr</code>, users should use the method <code>lock()</code>
to get its original <code>shared_ptr</code> object first.</p>
<h3 id="code-snippet-from-stdweak_ptr">Code Snippet from
<code>std::weak_ptr</code></h3>
<p>Let's take a look at the implementation in libstdc++ (detail is
omitted):<a href="#fn8" class="footnote-ref" id="fnref8"
role="doc-noteref"><sup>8</sup></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">weak_ptr</span> :</span> <span class="keyword">public</span> __weak_ptr&lt;_Tp&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the shared_ptr object</span></span><br><span class="line">    <span class="function">shared_ptr&lt;_Tp&gt; <span class="title">lock</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> shared_ptr&lt;_Tp&gt;(*<span class="keyword">this</span>, std::nothrow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>weak_ptr</code> inherits from <code>__weak_ptr</code> and using
<code>lock()</code> would help the user get a converted
<code>shared_ptr</code> object.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">weak_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The default constructor would assign the pointer</span></span><br><span class="line">    <span class="comment">// and the reference count as null and 0 separately</span></span><br><span class="line">    <span class="keyword">constexpr</span> __weak_ptr() <span class="keyword">noexcept</span></span><br><span class="line">    : _M_ptr(<span class="literal">nullptr</span>), _M_refcount()</span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assign the reference count managed by the shared_ptr object</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Yp&gt;</span><br><span class="line">    _Assignable&lt;_Yp&gt; <span class="keyword">operator</span>=(<span class="keyword">const</span> __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        _M_ptr = __r._M_ptr;</span><br><span class="line">        _M_refcount = __r._M_refcount;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the reference count held by the shared_ptr object</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> _M_refcount._M_get_use_count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Equivelent to use_count() == 0,</span></span><br><span class="line">    <span class="comment">// meaning that the manged object has been deleted</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">expired</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _M_refcount._M_get_use_count() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Construct an empty weak_ptr and replace with it</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        __weak_ptr().<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    element_type*      _M_ptr;        <span class="comment">// Contained pointer.</span></span><br><span class="line">    __weak_count&lt;_Lp&gt;  _M_refcount;   <span class="comment">// Reference counter.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Briefly, <code>weak_ptr</code> can be used to track the managed
object held by <code>shared_ptr</code>. It also has its own weak
reference count.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">weak_count</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Increase the &quot;weak&quot; reference counter</span></span><br><span class="line">    __weak_count&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> __shared_count&lt;_Lp&gt;&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">        <span class="keyword">if</span> (__tmp != <span class="literal">nullptr</span>)</span><br><span class="line">            __tmp-&gt;_M_weak_add_ref();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">            _M_pi-&gt;_M_weak_release();</span><br><span class="line"></span><br><span class="line">        _M_pi = __tmp;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Increase the &quot;weak&quot; reference counter</span></span><br><span class="line">    __weak_count&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> __weak_count&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">        <span class="keyword">if</span> (__tmp != <span class="literal">nullptr</span>)</span><br><span class="line">            __tmp-&gt;_M_weak_add_ref();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">            _M_pi-&gt;_M_weak_release();</span><br><span class="line"></span><br><span class="line">        _M_pi = __tmp;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> __<span class="title">shared_count</span>&lt;</span>_Lp&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define the operations of the stored pointer</span></span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;*  _M_pi;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The mechanism of the reference counter in <code>weak_ptr</code> is
quite similar to <code>shared_ptr</code>. Yet, <code>weak_ptr</code>
mainly operates upon weak reference.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp = __default_lock_policy&gt;</span><br><span class="line">class _Sp_counted_base : <span class="keyword">public</span> _Mutex_base&lt;_Lp&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called when _M_use_count drops to zero, to release the resources</span></span><br><span class="line">    <span class="comment">// managed by *this. (Can be redefined by the deriving class)</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> _M_dispose() <span class="keyword">noexcept</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called when _M_weak_count drops to zero.</span></span><br><span class="line">    <span class="comment">// (Can be redefined by the deriving class)</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> _M_destroy() <span class="keyword">noexcept</span></span><br><span class="line">    &#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    _Atomic_word  _M_use_count;     <span class="comment">// #shared</span></span><br><span class="line">    _Atomic_word  _M_weak_count;    <span class="comment">// #weak + (#shared != 0)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>_M_use_count</code> is used by <code>shared_ptr</code> to store
the strong reference count, whereas <code>_M_weak_count</code> is used
by <code>weak_ptr</code> to store the weak reference count.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Sp_counted_base&lt;_S_single&gt;::_M_release() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (--_M_use_count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// the managed object will be destroyed once it is not held by any shared_ptr</span></span><br><span class="line">        _M_dispose();</span><br><span class="line">        <span class="keyword">if</span> (--_M_weak_count == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// the control block is not released until its weak_ptr count reaches zero</span></span><br><span class="line">            _M_destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Sp_counted_base&lt;_S_single&gt;::_M_weak_release() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// the control block is not released until its weak_ptr count reaches zero</span></span><br><span class="line">    <span class="keyword">if</span> (--_M_weak_count == <span class="number">0</span>)</span><br><span class="line">        _M_destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Once the weak reference count reaches zero, the control block will be
deallocated.</p>
<h3
id="example-1-weak_ptr-does-not-increase-the-reference-count-held-by-shared_ptr">Example
1: <code>weak_ptr</code> does not increase the reference count held by
<code>shared_ptr</code></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr&lt;Obj&gt; sp = make_shared&lt;Obj&gt;(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;count = &quot;</span> &lt;&lt; sp.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    weak_ptr&lt;Obj&gt; wp = sp;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;count = &quot;</span> &lt;&lt; sp.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&lt;&lt;... END ...&gt;&gt;\n\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Construct <span class="number">1</span></span><br><span class="line">count = <span class="number">1</span></span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&lt;... END ...&gt;&gt;</span><br><span class="line"></span><br><span class="line">Destroy <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>Aside from this, <code>wp.use_count()</code> returns the number of
<code>shared_ptr</code> that manages this object; thus the value should
be the same as <code>sp.use_count()</code>.</p>
<h3 id="example-2-access-the-object-through-lock">Example 2: access the
object through <code>lock()</code></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr&lt;Obj&gt; sp = make_shared&lt;Obj&gt;(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    weak_ptr&lt;Obj&gt; wp = sp;</span><br><span class="line"></span><br><span class="line">    wp.<span class="built_in">lock</span>()-&gt;<span class="built_in">SayHi</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&lt;&lt;... END ...&gt;&gt;\n\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Construct <span class="number">1</span></span><br><span class="line">Hi <span class="number">1</span>!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&lt;... END ...&gt;&gt;</span><br><span class="line"></span><br><span class="line">Destroy <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>Users should use <code>lock()</code> to get the
<code>shared_ptr</code> pointer to access this object.</p>
<h3
id="example-3-use-expired-to-check-the-availability-of-an-object">Example
3: use <code>expired()</code> to check the availability of an
object</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    weak_ptr&lt;Obj&gt; wp;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        shared_ptr&lt;Obj&gt; sp = make_shared&lt;Obj&gt;(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        wp = sp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (wp.<span class="built_in">expired</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Object has been destroyed!&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&lt;&lt;... END ...&gt;&gt;\n\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Construct <span class="number">1</span></span><br><span class="line">Destroy <span class="number">1</span></span><br><span class="line">Object has been destroyed!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&lt;... END ...&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>expired()</code> is equivelent to
<code>use_count() == 0</code>.</p>
<h3 id="example-4-release-the-reference-from-weak_ptr">Example 4:
release the reference from <code>weak_ptr</code></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr&lt;Obj&gt; sp = make_shared&lt;Obj&gt;(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    weak_ptr&lt;Obj&gt; wp = sp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//wp = nullptr;         // error</span></span><br><span class="line">    wp.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//wp.lock()-&gt;SayHi();   // error, not available anymore</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&lt;&lt;... END ...&gt;&gt;\n\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Construct 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&lt;... END ...&gt;&gt;</span><br><span class="line"></span><br><span class="line">Destroy 1</span><br></pre></td></tr></table></figure>
<p>You cannot assign a <code>weak_ptr</code> object as null
directly.</p>
<h2 id="construct-an-array-of-weak_ptr-objects">Construct an Array of
<code>weak_ptr</code> Objects</h2>
<p>You cannot construct an array of <code>weak_ptr</code> objects as the
approach in <code>unique_ptr</code> and <code>shared_ptr</code> because
the operator <code>[]</code> to access the array elements is not
defined.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">weak_ptr&lt;Obj[]&gt; wpArray;    <span class="comment">// ??? wpArray[i] is not defined</span></span><br></pre></td></tr></table></figure>
<p>A workaround is to declare it as a regular array, then tackle its
elements separately:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">weak_ptr&lt;Obj&gt; wpArray[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">shared_ptr&lt;Obj&gt; sp1 = make_shared&lt;Obj&gt;(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">shared_ptr&lt;Obj&gt; sp2 = make_shared&lt;Obj&gt;(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">shared_ptr&lt;Obj&gt; sp3 = make_shared&lt;Obj&gt;(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">wpArray[<span class="number">0</span>] = sp1;</span><br><span class="line">wpArray[<span class="number">1</span>] = sp2;</span><br><span class="line">wpArray[<span class="number">2</span>] = sp3;</span><br></pre></td></tr></table></figure>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="https://gcc.gnu.org/onlinedocs/gcc-11.2.0/libstdc++/api/a00371_source.html">Source
code of std::unique_ptr in GCC 11.2</a><a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a
href="https://gcc.gnu.org/onlinedocs/gcc-11.2.0/libstdc++/api/a00371_source.html">Source
code of std::make_unique in GCC 11.2</a><a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3588.txt">A
proposal to add make_unique for symmetry, simplicity, and safety</a><a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0400r0.html">C++17
- Wording for Order of Evaluation of Function Arguments</a><a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><a
href="https://gcc.gnu.org/onlinedocs/gcc-11.2.0/libstdc++/api/a17923_source.html">Source
code of std::shared_ptr in GCC 11.2</a><a href="#fnref5"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p><a
href="https://gcc.gnu.org/onlinedocs/gcc-11.2.0/libstdc++/api/a00494_source.html">Source
code of __shared_ptr class in GCC 11.2</a><a href="#fnref6"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p><a
href="https://stackoverflow.com/questions/13061979/shared-ptr-to-an-array-should-it-be-used/13062069#13062069">shared_ptr
to an array : should it be used?</a><a href="#fnref7"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p><a
href="https://gcc.gnu.org/onlinedocs/gcc-11.2.0/libstdc++/api/a00494_source.html">Source
code of std::weak_ptr in GCC 11.2</a><a href="#fnref8"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>Programming Language</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Optimisation</tag>
      </tags>
  </entry>
  <entry>
    <title>Sampling - Inverse Transformation Method</title>
    <url>/2021/09/11/Inverse-Transform-Method/</url>
    <content><![CDATA[<p>Sometimes, we may wanna simulate certain random variable to get the
desired approximation. Yet, if the scenario is rather complicated, the
computation cost can be exorbitant. With the help of <strong>inverse
transformation method</strong>, we are able to generate many special
random variables efficienctly.</p>
<span id="more"></span>
<h2 id="a-toy-example">A Toy Example</h2>
<blockquote>
<p>With replacement, we draw cards at random from an ordinary deck of 52
cards, and successively until an ACE is drawn. What is the probability
of exactly 10 draws?</p>
</blockquote>
<p>Apparently, let <span class="math inline">\(X\)</span> be the number
of draws until the first ace. The random variable <span
class="math inline">\(X\)</span> is of <strong>geometric
distribution</strong> with the parameter <span class="math inline">\(p =
\frac{1}{13}\)</span>. The answer of the desired probability is</p>
<p><span class="math display">\[
P(x) = (1-p)^{x-1} * p = (\frac{12}{13})^9 * (\frac{1}{13})
\]</span></p>
<h2 id="simulating-x">Simulating <span
class="math inline">\(X\)</span></h2>
<p>Now, if we wanna approximate the desired probability by simulating
<span class="math inline">\(X\)</span>, an intuitive way might look like
as below:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### Pseudo-code of Simulation</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span>    <span class="comment"># iterator</span></span><br><span class="line">k = <span class="number">0</span>    <span class="comment"># Record the desired events</span></span><br><span class="line"><span class="keyword">while</span> i &lt; N:      <span class="comment"># Repeat N trials</span></span><br><span class="line">    draws = <span class="number">0</span>     <span class="comment"># Count how many draws when the first ACE appears</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:   <span class="comment"># Draw the card with replacement until it is an ACE</span></span><br><span class="line">        draws +=<span class="number">1</span></span><br><span class="line">        Generate a random sample x <span class="keyword">from</span> [A,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,..<span class="number">.9</span>,<span class="number">10</span>,J,Q,K]</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">is</span> ACE:   <span class="comment"># Let 1 represent the ACE</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> draws <span class="keyword">is</span> <span class="number">10</span>:  <span class="comment"># Number of draws is exactly 10</span></span><br><span class="line">        k +=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    i +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">prob = k/N   <span class="comment"># The approximate value</span></span><br></pre></td></tr></table></figure>
<p>From the experiment, it can be observed that <span
class="math inline">\(N\)</span> has to be quite large (&gt;10000) if we
would like to get enough accuracy:</p>
<img src="/2021/09/11/Inverse-Transform-Method/geomtric_sim.png" class="" title="This is an image">
<p>Below is the source code:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># N trials</span></span><br><span class="line"><span class="comment"># k: Count the desired events obtained in N trials</span></span><br><span class="line"></span><br><span class="line">N = [<span class="number">100</span>, <span class="number">250</span>, <span class="number">500</span>, <span class="number">750</span>, </span><br><span class="line">     <span class="number">1000</span>, <span class="number">1500</span>, <span class="number">2000</span>, <span class="number">2500</span>, <span class="number">3000</span>, <span class="number">3500</span>, <span class="number">4000</span>, <span class="number">4500</span>, <span class="number">5000</span>,</span><br><span class="line">     <span class="number">5500</span>, <span class="number">6000</span>, <span class="number">6500</span>, <span class="number">7000</span>, <span class="number">7500</span>, <span class="number">8000</span>, <span class="number">8500</span>, <span class="number">9000</span>, <span class="number">9500</span>,</span><br><span class="line">     <span class="number">10000</span>, <span class="number">12500</span>, <span class="number">15000</span>, <span class="number">17500</span>, <span class="number">20000</span>]</span><br><span class="line">approx = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> N:</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="comment"># draw the card with replacement until it is ACE</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            j +=<span class="number">1</span></span><br><span class="line">            draw = np.random.randint(<span class="number">1</span>, <span class="number">13</span>)</span><br><span class="line">            <span class="keyword">if</span> draw == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">10</span>:  <span class="comment"># draw number is 10</span></span><br><span class="line">            k +=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        i +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    approx.append(k/n)</span><br><span class="line"></span><br><span class="line">ans = (<span class="number">12</span>/<span class="number">13</span>)**<span class="number">9</span> * (<span class="number">1</span>/<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">plt.scatter(x=N, y=approx)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Number of trials&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Approximate probability&#x27;</span>)</span><br><span class="line">plt.axhline(y=ans, color=<span class="string">&#x27;r&#x27;</span>, linestyle=<span class="string">&#x27;-&#x27;</span>, label=<span class="string">&#x27;Answer&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.title(<span class="string">&#x27;Simulation to get the Ace at exactly 10 draws&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>However, this approach is not efficient because the time complexity
is proportional to the draw number. Thus, let's introduce the inverse
transformation method. By this method, we are able to get the same
result as well but only need to choose one random point in (0,1),
significantly reducing the time cost.</p>
<h2 id="inverse-transformation-method">Inverse Transformation
Method</h2>
<p>Let <span class="math inline">\(F(X) = P(X \leq x)\)</span> be the
probability distribution function of the random variable <span
class="math inline">\(X\)</span>. Remember that for uniform random
variable <span class="math inline">\(U\)</span> over <span
class="math inline">\((0,1)\)</span>,</p>
<p><span class="math display">\[
F(U) = P(U \leq x) = x, x \in (0,1) \tag{1}
\]</span></p>
<p>Imagine that our objective is to simulate a random variable <span
class="math inline">\(X\)</span> from a uniform random variable <span
class="math inline">\(U\)</span>, i.e., <span class="math inline">\(P(X
\leq x) = P(T(U) \leq x)\)</span>. We hope to find a transformation
<span class="math inline">\(T\)</span> that is able to convert the
random variable <span class="math inline">\(U\)</span> into our desired
<span class="math inline">\(X\)</span>.</p>

$$
\displaylines {
P(X \leq x) \\
= P(T(U) \leq x) \\
= P(U \leq T^{-1}(x)) \\
}
$$

<p>Remember that <span class="math inline">\(F(X) = P(X \leq x)\)</span>
and from <span class="math inline">\((1)\)</span>:</p>

$$
\displaylines {
P(U \leq T^{-1}(x)) \\
= P(U \leq F(x)) \\
= P(F^{-1}(U) \leq x)
}
$$

<p><span class="math display">\[
\longrightarrow X = F^{-1}(U) \tag{2}
\]</span></p>
<p>From <span class="math inline">\((2)\)</span>, we know the
transformation <span class="math inline">\(T\)</span> we are looking for
is just <span class="math inline">\(F^{-1}\)</span>. Therefore, after
solving <span class="math inline">\(F^{-1}\)</span>, we are able to
generate the desired <span class="math inline">\(X\)</span> from uniform
random variable <span class="math inline">\(U\)</span> directly without
complications.<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></p>
<h2
id="simulating-geometric-distribution-via-inverse-transformation-method">Simulating
Geometric Distribution via Inverse Transformation Method</h2>
<p>Back to our original problem, we wanna simulate <span
class="math inline">\(X\)</span> in the toy example, and we know that
the <span class="math inline">\(F(x)\)</span> of geometric distribution
with parameter <span class="math inline">\(p\)</span> is</p>
<p><span class="math display">\[
F(x) = 1 - (1-p)^{x-1}
\]</span></p>
<p>Solve <span class="math inline">\(u = F(x)\)</span>:</p>

$$
\displaylines {
u = 1 - (1-p)^{x-1} \\
x = 1 + \frac{\log{(1-u)}}{\log{(1-p)}}
}
$$

<p><span class="math display">\[
\equiv 1 + \frac{\log{u}}{\log{(1-p)}}  \tag{3}
\]</span></p>
<p>If <span class="math inline">\(u\)</span> is a random number variable
from (0,1), then <span class="math inline">\((1-u)\)</span> is a random
number variable from (0,1) as well.</p>
<p>Now, from <span class="math inline">\((3)\)</span>, we are able to
generate <span class="math inline">\(X\)</span> from <span
class="math inline">\(U\)</span> efficiently. Because <span
class="math inline">\(X\)</span> is an integer, we use the <em>floor
operation</em> (with the <em>ceiling</em> is also equivalent):</p>
<p><span class="math display">\[
X = \lfloor 1 + \frac{\log{u}}{\log{(1-p)}} \rfloor
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### Pseudo-code of Geometric Distribution Simulation with Inverse Transform method</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span>    <span class="comment"># iterator</span></span><br><span class="line">k = <span class="number">0</span>    <span class="comment"># Record the desired events</span></span><br><span class="line"><span class="keyword">while</span> i &lt; N:      <span class="comment"># Repeat N trials</span></span><br><span class="line">    Generate a uniform random variable u <span class="keyword">from</span> (<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># p is the parameter of geometric distribution</span></span><br><span class="line">    X = floor(<span class="number">1</span> + log(u)/log(<span class="number">1</span>-p))   <span class="comment"># inverse transform</span></span><br><span class="line">    <span class="keyword">if</span> X <span class="keyword">is</span> <span class="number">10</span>:</span><br><span class="line">        k +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    i +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">prob = k/N   <span class="comment"># The approximate value</span></span><br></pre></td></tr></table></figure>
<p>Below is the experimental result and the related source code:</p>
<img src="/2021/09/11/Inverse-Transform-Method/geomtric_sim_with_inv.png" class="" title="This is an image">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log, floor</span><br><span class="line"></span><br><span class="line"><span class="comment"># N trials</span></span><br><span class="line"><span class="comment"># k: Count the desired events obtained in N trials</span></span><br><span class="line"></span><br><span class="line">N = [<span class="number">100</span>, <span class="number">250</span>, <span class="number">500</span>, <span class="number">750</span>, </span><br><span class="line">     <span class="number">1000</span>, <span class="number">1500</span>, <span class="number">2000</span>, <span class="number">2500</span>, <span class="number">3000</span>, <span class="number">3500</span>, <span class="number">4000</span>, <span class="number">4500</span>, <span class="number">5000</span>,</span><br><span class="line">     <span class="number">5500</span>, <span class="number">6000</span>, <span class="number">6500</span>, <span class="number">7000</span>, <span class="number">7500</span>, <span class="number">8000</span>, <span class="number">8500</span>, <span class="number">9000</span>, <span class="number">9500</span>,</span><br><span class="line">     <span class="number">10000</span>, <span class="number">12500</span>, <span class="number">15000</span>, <span class="number">17500</span>, <span class="number">20000</span>]</span><br><span class="line">approx = []</span><br><span class="line">p = <span class="number">1</span>/<span class="number">13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> N:</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="comment"># inverse transformation method</span></span><br><span class="line">        u = np.random.rand()</span><br><span class="line">        X = floor(<span class="number">1</span> + log(u)/log(<span class="number">1</span>-p))</span><br><span class="line">        <span class="keyword">if</span> X == <span class="number">10</span>:</span><br><span class="line">            k +=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        i +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    approx.append(k/n)</span><br><span class="line"></span><br><span class="line">ans = (<span class="number">12</span>/<span class="number">13</span>)**<span class="number">9</span> * (<span class="number">1</span>/<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">plt.scatter(x=N, y=approx)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Number of trials&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Approximate probability&#x27;</span>)</span><br><span class="line">plt.axhline(y=ans, color=<span class="string">&#x27;r&#x27;</span>, linestyle=<span class="string">&#x27;-&#x27;</span>, label=<span class="string">&#x27;Answer&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.title(<span class="string">&#x27;Simulation with Inverse Tranformation Method&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="performance-comparison">Performance Comparison</h2>
<p>Let N be 500000 trials.</p>
<p>Original method:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### Original Method</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> perf_counter</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">t1_start = perf_counter()</span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">500000</span>:</span><br><span class="line">    <span class="comment"># draw the card with replacement until it is ACE</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        j +=<span class="number">1</span></span><br><span class="line">        draw = np.random.randint(<span class="number">1</span>, <span class="number">13</span>)</span><br><span class="line">        <span class="keyword">if</span> draw == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> j == <span class="number">10</span>:  <span class="comment"># draw number is 10</span></span><br><span class="line">        k +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    i +=<span class="number">1</span></span><br><span class="line">t1_stop = perf_counter()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Elapsed time (sec):&quot;</span>, t1_stop-t1_start) </span><br></pre></td></tr></table></figure>
<p>Inverse transformation method:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> perf_counter</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">t1_start = perf_counter()  </span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">500000</span>:</span><br><span class="line">    <span class="comment"># inverse transformation method</span></span><br><span class="line">    u = np.random.rand()</span><br><span class="line">    X = floor(<span class="number">1</span> + log(u)/log(<span class="number">1</span>-p))</span><br><span class="line">    <span class="keyword">if</span> X == <span class="number">10</span>:</span><br><span class="line">        k +=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    i +=<span class="number">1</span></span><br><span class="line">t1_stop = perf_counter()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Elapsed time (sec):&quot;</span>, t1_stop-t1_start) </span><br></pre></td></tr></table></figure>
<p>Results:</p>
<table>
<thead>
<tr class="header">
<th>N = 500000 (trials)</th>
<th>Elapsed Time (sec)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Original Method</td>
<td>10.832</td>
</tr>
<tr class="even">
<td>Inverse Transformation Method</td>
<td>0.363</td>
</tr>
</tbody>
</table>
<p>We can observe that the elapsed time has been substantially reduced
after applying inverse transformation method.</p>
<blockquote>
<p>Note that the inverse transformation method is to mainly improve the
computation cost. It does <strong>not</strong> increase the convergence
rate. From the previous experimental results, you can see that the N
trials required to converge are roughly the same for both methods.</p>
</blockquote>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>For rigorous proof, you can refer to <a
href="https://en.wikipedia.org/wiki/Inverse_transform_sampling">Inverse
transform sampling</a>. The aim here is to grasp the idea intuitively.<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>Mathematics</category>
        <category>Probability and Statistics</category>
      </categories>
      <tags>
        <tag>Simulation</tag>
        <tag>Python</tag>
        <tag>Sampling</tag>
        <tag>Inverse Transformation Method</tag>
      </tags>
  </entry>
  <entry>
    <title>[C++] A Note about Template Copy/Move Constructor</title>
    <url>/2023/05/20/cpp-a-note-about-template-copy-move-constructor/</url>
    <content><![CDATA[<p>In C++, even though a function generated from a function template has
the same name and the same type as the ordinary function, they are
<strong>never equivalent</strong>. Besides, the <a
href="https://en.cppreference.com/w/cpp/language/overload_resolution#Best_viable_function">non-template
function is more preferred</a>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(T)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;template foo()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;ordinary foo()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">5</span>);     <span class="comment">// print &quot;oridinary foo()&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>On top of that, it is not easy to templify a copy/move constructor
because the compiler may implicitly define a copy/move constructor.</p>
<span id="more"></span>
<h2 id="example">Example</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Obj</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">Obj</span> (<span class="keyword">const</span> T&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;template copy ctor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>It still uses the predefined copy constructor:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Obj a;</span><br><span class="line">Obj b&#123;a&#125;;   <span class="comment">// use the predefined copy constructor rather than the template one</span></span><br></pre></td></tr></table></figure>
<p><strong>The reason is that a member function template is never a <a
href="https://en.cppreference.com/w/cpp/language/member_functions">special
member function</a> and can be ignored when the latter is
needed</strong>. Taking the above for an instance, the implicitly
generated copy constructor is chosen.</p>
<h2 id="deleting-predefined-copy-constructor">Deleting Predefined Copy
Constructor</h2>
<p>One may want to delete the the predefined copy constructor:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Obj</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Obj</span>(<span class="keyword">const</span> Obj&amp;) = <span class="keyword">delete</span>;   <span class="comment">// copying Obj results in an error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">Obj</span> (<span class="keyword">const</span> T&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;template copy ctor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>However, this would result in an error when trying to copy
<code>Obj</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Obj a;</span><br><span class="line">Obj b&#123;a&#125;;   <span class="comment">// error: call to deleted constructor of &#x27;Obj&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="const-volatile-trick"><code>const volatile</code> Trick</h2>
<p>There is a tricky solution for this: deleting the copy constructor
with <code>const volatile</code> type. With this, it prevents another
copy constructor from being implicitly generated<a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> and
the template copy constuctor can be preferred over the deleted copy
constructor for <strong>non-volatile</strong> types:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Obj</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the predefined copy constructor is deleted</span></span><br><span class="line">    <span class="comment">// with conversion to volatile to enable better match</span></span><br><span class="line">    <span class="built_in">Obj</span>(<span class="keyword">const</span> <span class="keyword">volatile</span> Obj&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">Obj</span> (<span class="keyword">const</span> T&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;template copy ctor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The overload resolution candidates now are
<code>Obj(const volatile Obj&amp;)</code> and
<code>Obj&lt;Obj&amp;&gt;(const Obj&amp;)</code>, and the latter is a
better match:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Obj a;</span><br><span class="line">Obj b&#123;a&#125;;   <span class="comment">// call to the templified version: print &quot;template copy ctor&quot;</span></span><br></pre></td></tr></table></figure>
<hr />
<p>Similarly, we can templify move constructor or other special member
functions by deleting the predefined special member functions for
<code>const volatile</code> type.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Obj</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Obj</span> (<span class="keyword">const</span> <span class="keyword">volatile</span> Obj&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">Obj</span> (T&amp;&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;template move ctor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Obj a;</span><br><span class="line">    Obj c&#123;std::<span class="built_in">move</span>(a)&#125;;  <span class="comment">// print &quot;template move ctor&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note that this still leads to error if we try to operate
<code>Obj</code> with volatile type. Fortunately, it is rarely used.</p>
</blockquote>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>A non-template constructor for class X is a copy
constructor if its first parameter is of type <code>X&amp;</code>,
<code>const X&amp;</code>, <code>volatile X&amp;</code> or
<code>const volatile X&amp;</code><a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>Programming Language</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Optimisation</tag>
      </tags>
  </entry>
  <entry>
    <title>[C++] Implement std::decay from scratch</title>
    <url>/2023/05/27/cpp-implement-decay/</url>
    <content><![CDATA[<p>Since C++11, <code>std::decay</code> is introduced along with
<code>&lt;type_traits&gt;</code>. It is used to <em>decay</em> a type,
or to convert a type into its corresponding <strong>by-value</strong>
type. It will remove any top-level cv-qualifiers(<code>const</code>,
<code>volatile</code>) and reference qualifiers for the specified type.
For example, <code>int&amp;</code> is turned into <code>int</code> and
an array type becomes a pointer to its element types. Knowing its usage,
we could try to implement our own version of
<code>std::decay</code>.</p>
<span id="more"></span>
<p>For <code>std::decay&lt;T&gt;</code>, the transformation of type
<code>T</code> contains following parts:</p>
<ul>
<li>Removing references</li>
<li>Removing cv-qualifiers (<code>const</code> and
<code>volatile</code>)</li>
<li>For an array type, yielding a pointer to its element type</li>
<li>For a function type, yiedling its function pointer type</li>
</ul>
<h2 id="removing-references">Removing References</h2>
<p>Firstly, we implement <code>RemoveReferenceT</code> trait to remove
references:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RemoveReferenceT</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove lvalue reference</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RemoveReferenceT</span>&lt;</span>T&amp;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove ravlue reference</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RemoveReferenceT</span>&lt;</span>T&amp;&amp;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alias for usage convenience</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> RemoveReference = <span class="keyword">typename</span> RemoveReferenceT&lt;T&gt;::Type;</span><br></pre></td></tr></table></figure>
<p>Results:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">RemoveReference&lt;<span class="keyword">int</span>&gt;          <span class="comment">// int</span></span><br><span class="line">RemoveReference&lt;<span class="keyword">int</span>&amp;&gt;         <span class="comment">// int</span></span><br><span class="line">RemoveReference&lt;<span class="keyword">int</span>&amp;&amp;&gt;        <span class="comment">// int</span></span><br><span class="line">RemoveReference&lt;<span class="keyword">const</span> <span class="keyword">int</span>&gt;    <span class="comment">// const int</span></span><br><span class="line">RemoveReference&lt;<span class="keyword">const</span> <span class="keyword">int</span>&amp;&gt;   <span class="comment">// const int</span></span><br></pre></td></tr></table></figure>
<p>The corresponding type trait in C++ STL is <a
href="https://en.cppreference.com/w/cpp/types/remove_reference">std::remove_reference</a></p>
<h2 id="removing-cv-qualifiers">Removing cv-qualifiers</h2>
<p>Then, <code>RemoveConstT</code> and <code>RemoveVolatileT</code> are
to remove <code>const</code> and <code>volatile</code> qualifiers,
respectively:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RemoveConstT</span> &#123;</span></span><br><span class="line">	<span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove const</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RemoveConstT</span>&lt;</span><span class="keyword">const</span> T&gt; &#123;</span><br><span class="line">	<span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alias for usage convenience</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> RemoveConst = <span class="keyword">typename</span> RemoveConstT&lt;T&gt;::Type;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RemoveVolatileT</span> &#123;</span></span><br><span class="line">	<span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove volatile</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RemoveVolatileT</span>&lt;</span><span class="keyword">volatile</span> T&gt; &#123;</span><br><span class="line">	<span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alias for usage convenience</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> RemoveVolatile = <span class="keyword">typename</span> RemoveVolatileT&lt;T&gt;::Type;</span><br></pre></td></tr></table></figure>
<p><code>RemoveConstT</code> and <code>RemoveVolatileT</code> can be
composed into <code>RemoveCVT</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// metafunction forwarding: inherit the Type member from RemoveConstT</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RemoveCVT</span> :</span> RemoveConstT&lt;RemoveVolatile&lt;T&gt;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alias for usage convenience</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> RemoveCV = <span class="keyword">typename</span> RemoveCVT&lt;T&gt;::Type;</span><br></pre></td></tr></table></figure>
<p>Results:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">RemoveCV&lt;<span class="keyword">int</span>&gt;                  <span class="comment">// int</span></span><br><span class="line">RemoveCV&lt;<span class="keyword">const</span> <span class="keyword">int</span>&gt;            <span class="comment">// int</span></span><br><span class="line">RemoveCV&lt;<span class="keyword">volatile</span> <span class="keyword">int</span>&gt;         <span class="comment">// int</span></span><br><span class="line">RemoveCV&lt;<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">int</span>&gt;   <span class="comment">// int</span></span><br><span class="line"></span><br><span class="line">RemoveCV&lt;<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">int</span>*&gt;  <span class="comment">// const volatile int*</span></span><br><span class="line">RemoveCV&lt;<span class="keyword">int</span>* <span class="keyword">const</span> <span class="keyword">volatile</span>&gt;  <span class="comment">// int*</span></span><br></pre></td></tr></table></figure>
<p>The corresponding type traits in C++ STL: <a
href="https://en.cppreference.com/w/cpp/types/remove_cv">std::remove_cv,
std::remove_const, std::remove_volatile</a></p>
<blockquote>
<p>Note that <code>const volatile int*</code> is not changed because the
pointer itself is neither const or volatile. (See <a
href="https://learn.microsoft.com/en-us/cpp/cpp/const-and-volatile-pointers?view=msvc-170">const
and volatile pointers</a>)</p>
</blockquote>
<p>With <code>RemoveReference</code> and <code>RemoveCVT</code> traits
above, we can get a decay trait for nonarray and nonfunction cases:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// remove reference firstly and then cv-qualifier</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecayT</span> :</span> RemoveCVT&lt;RemoveReference&lt;T&gt;&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>We name our version <code>DecayT</code> in order not to confuse with
original <code>std::decay</code>.</p>
<h2 id="array-to-pointer-decay">Array-to-pointer Decay</h2>
<p>Now we take array types into account. Below are partial
specialisations to convert an array type into a pointer to its element
type:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unbounded array</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecayT</span>&lt;</span>T[]&gt; &#123;</span><br><span class="line">	<span class="keyword">using</span> Type = T*;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bounded array</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecayT</span>&lt;</span>T[N]&gt; &#123;</span><br><span class="line">	<span class="keyword">using</span> Type = T*;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Similarly, C++ STL provides <a
href="https://en.cppreference.com/w/cpp/types/is_array">std::is_array</a>
to check whether <code>T</code> is an array type.</p>
<h2 id="function-to-pointer-decay">Function-to-pointer Decay</h2>
<p>We want to recognise a function regardless of its return type and
parameter types, and then get its function pointer. Because there are
different number of parameters, we need to employ variadic
templates:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ret, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecayT</span>&lt;</span><span class="built_in">Ret</span>(Args...)&gt; &#123;</span><br><span class="line">	<span class="keyword">using</span> Type = <span class="built_in">Ret</span>(*)(Args...);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// specialisation for variadic function</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ret, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecayT</span>&lt;</span><span class="built_in">Ret</span>(Args..., ...)&gt; &#123;</span><br><span class="line">	<span class="keyword">using</span> Type = <span class="built_in">Ret</span>(*)(Args..., ...);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>C++ STL also provides <a
href="https://en.cppreference.com/w/cpp/types/is_function">std::is_function</a>
to check the function type.</p>
<blockquote>
<p>It is worth mentioning that many compilers nowadays use fundamental
properties to check a function type for better performance instead<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">!std::is_const&lt;<span class="keyword">const</span> T&gt;::value &amp;&amp; !std::is_reference&lt;T&gt;::value</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Functions are not objects; thus, <code>const</code> cannot be
applied</li>
<li>When <code>const T</code> fails to be a const-qualified type,
<code>T</code> is either a function type or a reference type</li>
<li>We can rule out reference types to get only with function types for
<code>T</code></li>
</ul>
</blockquote>
<p>Now, with alias template for convenience, we could get our own
version of decay trait, <code>Decay</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Decay = <span class="keyword">typename</span> DecayT&lt;T&gt;::Type;</span><br></pre></td></tr></table></figure>
<p>Results:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Decay&lt;<span class="keyword">int</span>&amp;&gt;         <span class="comment">// int</span></span><br><span class="line">Decay&lt;<span class="keyword">const</span> <span class="keyword">int</span>&gt;    <span class="comment">// int</span></span><br><span class="line">Decay&lt;<span class="keyword">int</span> <span class="keyword">const</span>&amp;&gt;   <span class="comment">// int</span></span><br><span class="line">Decay&lt;<span class="keyword">int</span>[]&gt;        <span class="comment">// int*</span></span><br><span class="line">Decay&lt;<span class="keyword">int</span>[<span class="number">3</span>]&gt;       <span class="comment">// int*</span></span><br><span class="line">Decay&lt;<span class="keyword">int</span>[<span class="number">3</span>][<span class="number">2</span>]&gt;    <span class="comment">// int*</span></span><br><span class="line">Decay&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt;     <span class="comment">// int(*)(int)</span></span><br></pre></td></tr></table></figure>
<h2 id="in-comparison-with-stddecay">In Comparison with
<code>std::decay</code></h2>
<p>In fact, <a
href="https://timsong-cpp.github.io/cppwp/n4659/meta.trans.other#tab:type-traits.other">C++
standard defines std::decay</a> as:</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Template</th>
<th>Comments</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>template &lt;class T&gt; struct decay;</code></td>
<td>Let U be <code>remove_­reference_­t&lt;T&gt;</code>. If
<code>is_­array_­v&lt;U&gt;</code> is true, the member typedef type shall
equal <code>remove_­extent_­t&lt;U&gt;*</code>. If
<code>is_­function_­v&lt;U&gt;</code> is true, the member typedef type
shall equal <code>add_­pointer_­t&lt;U&gt;</code>. Otherwise the member
typedef type equals <code>remove_­cv_­t&lt;U&gt;</code>. [ Note: This
behavior is similar to the lvalue-to-rvalue, array-to-pointer, and
function-to-pointer conversions applied when an lvalue expression is
used as an rvalue, but also strips cv-qualifiers from class types in
order to more closely model by-value argument passing.  — end
note ]</td>
</tr>
</tbody>
</table>
<p>Most compilers directly follow the comments to implement the decay
trait. Our own version in this article is basically a step-by-step
implementation mentioned in the note for pedagogical purposes.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="https://stackoverflow.com/questions/59654482/how-is-stdis-function-implemented">How
is std::is_function implemented?</a><a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>Programming Language</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Implement SVM with SMO from scratch in Python</title>
    <url>/2022/07/30/Implement-SVM-with-SMO-from-scratch/</url>
    <content><![CDATA[<p><strong>Support vector machine</strong> (SVM) plays an important role
in machine learning. Actually, SVM is one of my favorite models because
of its analytical property. Its main idea is to find the optimal
hyperplane that can linearly separate the data, or maximise
<strong>margin</strong> in the feature space. It is one of the most
robust models based on statistical learning framework in <strong>VC
theory</strong> (Vapnik–Chervonenkis theory). The determination of the
model parameters is a quadratic programming problem, or <strong>convex
optimisation</strong> more specifically. Its solution is usually
<strong>sparse</strong>, and the new input prediction depends only on
the evaluation of a subset of training data with kernel function. One of
the most common and efficient approaches to train SVM is
<strong>sequential minimal optimisation</strong> (SMO), which breaks
down the problem into solving a pair of parameters analytically at each
step. Besides, SMO also eliminates the need for matrix storage issue
when the training data size is huge.</p>
<span id="more"></span>
<h2 id="recall-the-objective-function-of-svm">Recall the Objective
Function of SVM</h2>
<img src="/2022/07/30/Implement-SVM-with-SMO-from-scratch/svm_1.png" class="" title="Figure 1">
<p>We want to find a hyperplane <span class="math inline">\(w^T x + b =
0\)</span> and maximise the margin width <span
class="math inline">\(2M\)</span> in order to separate the data labeled
as <span class="math inline">\(y = \pm 1\)</span>. All data points
should be correctly classified, i.e. <span class="math inline">\(y_i(w^T
x_i + b) &gt; 0\)</span> for all <span
class="math inline">\(i\)</span>,</p>

$$
\displaylines {
\max_{w,b} M \\
\textrm{ s.t. } \frac{y_i(w^T x_i + b)}{ \Vert w \Vert} \ge M, \forall i=1,2,...,N
}
$$

<p>The above optimisation problem can be converted into a dual form of
Lagrangian function, maximising <span
class="math inline">\(L\)</span>:</p>

$$
\displaylines {
L(\alpha)=\sum^{N}_{i} \alpha_i - \frac{1}{2} \sum^{N}_{i}\sum^{N}_{j} y_i y_j \alpha_i \alpha_j {x_i}^T x_j \\
\textrm{ s.t. } 0 \le \alpha_i,  \forall i \\
\textrm{ and } \sum^{N}_{i}y_i \alpha_i = 0
}
\tag{1}
$$

<p>The solution for <span class="math inline">\(w\)</span> is</p>
<p><span class="math display">\[
w = \sum^{N}_{i} y_i \alpha_i x_i \tag{2}
\]</span></p>
<p>If we allow some points are misclassified with penalty <span
class="math inline">\(C\)</span>, then the constraints of <span
class="math inline">\(\alpha_i\)</span> become</p>
<p><span class="math display">\[
0 \le \alpha_i \le C,  \forall i
\]</span></p>
<blockquote>
<p>For points with <span class="math inline">\(0 \lt \alpha_i \lt
C\)</span>, they just lie on the edge of the margin. In contrast, when
<span class="math inline">\(\alpha_i = 0\)</span>, it is in the decision
boundary and does not contribute to the prediction. The points with
<span class="math inline">\(\alpha_i = C\)</span> lie inside the margin
and might either be classified correctly or not.</p>
</blockquote>
<p>Points with non-zero <span class="math inline">\(\alpha_i\)</span>
are called <strong>support vectors</strong>. These can be demonstrated
as below:</p>
<img src="/2022/07/30/Implement-SVM-with-SMO-from-scratch/svm_2.png" class="" title="Figure 2">
<p>If we apply the feature transformation with kernel function <span
class="math inline">\(K(x_i, x_j)\)</span>, then the Lagrangian function
<span class="math inline">\((1)\)</span> turns into</p>
<p><span class="math display">\[
L(\alpha)=\sum^{N}_{i} \alpha_i - \frac{1}{2} \sum^{N}_{i}\sum^{N}_{j}
y_i y_j \alpha_i \alpha_j K(x_i, x_j) \tag{3}
\]</span></p>
<p>The constraints of Lagrangian multipliers are the same as before.</p>
<p>The predicted <span class="math inline">\(\hat{y}\)</span> of new
input is</p>
<p><span class="math display">\[
\hat{y} = \sum^{N}_{i} y_i \alpha_i K(x_i, x) + b  \tag{4}
\]</span></p>
<h2 id="sequential-minimal-optimisation">Sequential Minimal
Optimisation</h2>
<p>SMO process mainly contains two parts: one is to solve two Lagrangian
parameters analytically at a step, and then decide how to choose these
two parameters heuristically for speed up.</p>
<h3 id="solving-lagrangian-multipliers">Solving Lagrangian
Multipliers</h3>
<p>Using the constraint <span class="math inline">\(\sum^{N}_{i}y_i
\alpha_i = 0\)</span> in <span class="math inline">\((1)\)</span>, we
can get</p>
<p><span class="math display">\[
0 = y_1 \alpha^{old}_1 + y_2 \alpha^{old}_2 + \sum^{N}_{i=3}y_i \alpha_i
= y_1 \alpha^{new}_1 + y_2 \alpha^{new}_2 + \sum^{N}_{i=3}y_i \alpha_i
\]</span></p>
<p><span class="math display">\[
\Rightarrow y_1 \alpha^{old}_1 + y_2 \alpha^{old}_2 = k = y_1
\alpha^{new}_1 + y_2 \alpha^{new}_2  \tag{5}
\]</span></p>
<p>where <span class="math inline">\(k = -\sum^{N}_{i=3}y_i
\alpha_i\)</span>.</p>
<p>Remember that <span class="math inline">\(y\)</span> is either <span
class="math inline">\(1\)</span> or <span
class="math inline">\(-1\)</span> , with the constraint <span
class="math inline">\(0 \le \alpha_i \le C\)</span>, <span
class="math inline">\(\alpha_1\)</span> and <span
class="math inline">\(\alpha_2\)</span> can only lie on the diagonal
line segment shown as below:</p>
<img src="/2022/07/30/Implement-SVM-with-SMO-from-scratch/svm_3.png" class="" title="Figure 3">
<p>The Lagrangian multiplier <span
class="math inline">\(\alpha_2\)</span> can be solved by the first
derivative of the objective function to find its extremum. The
analytical form to solve <span class="math inline">\(\alpha_2\)</span>
is</p>
<p><span class="math display">\[
\alpha^{new}_2 = \alpha^{old}_2 + y_2 \frac{E_2 - E_1}{\eta},
\]</span></p>
<p><span class="math display">\[
E_i = \hat{y_i} - y_i  \text{, } \eta = K_{11} + K_{22} - 2K_{12}
\tag{6}
\]</span> <span class="math display">\[
K_{ij} = K(x_i, x_j)
\]</span></p>
<img src="/2022/07/30/Implement-SVM-with-SMO-from-scratch/svm_4.png" class="" title="Figure 4">
<h4 id="case-1-y_1-neq-y_2">Case 1: <span
class="math inline">\(y_1\)</span> <span
class="math inline">\(\neq\)</span> <span
class="math inline">\(y_2\)</span></h4>
<p><span class="math display">\[
L = \max(0, \alpha_2 - \alpha_1)
\]</span></p>
<p><span class="math display">\[
H = \min(C, C + \alpha_2 - \alpha_1)
\]</span></p>
<h4 id="case-2-y_1-y_2">Case 2: <span class="math inline">\(y_1 =
y_2\)</span></h4>
<p><span class="math display">\[
L = \max(0, \alpha_2 + \alpha_1 - C)
\]</span></p>
<p><span class="math display">\[
H = \min(C, \alpha_2 + \alpha_1)
\]</span></p>
<p>The <span class="math inline">\(\alpha^{new}_2\)</span> should be
bounded by <span class="math inline">\(L\)</span> and <span
class="math inline">\(H\)</span>.</p>

$$
  \alpha^{new}_2=\begin{cases}
    L, & \text{if $\alpha^{new}_2 \lt L$}.\\
    \alpha^{new}_2, & \text{if $L \le \alpha^{new}_2 \le H$}.\\
    H, & \text{if $\alpha^{new}_2 \gt H$}
  \end{cases}
$$

<p>We can then obtain <span
class="math inline">\(\alpha^{new}_1\)</span> by multiplying <span
class="math inline">\(y_1\)</span> on both sides in <span
class="math inline">\((5)\)</span>,</p>
<p><span class="math display">\[
\alpha^{new}_1 = \alpha^{old}_1 + y_1 y_2 (\alpha^{old}_2 -
\alpha^{new}_2) \tag{7}
\]</span></p>
<h4 id="abnormal-case-for-eta">Abnormal Case for <span
class="math inline">\(\eta\)</span></h4>
<p>Normally, <span class="math inline">\(\eta\)</span> should be greater
than 0. However, if we encounter the abnormal case that <span
class="math inline">\(\eta \le 0\)</span>, e.g. picking the same points
or an incorrect kernel that does not obey Mercer's condition, the full
version of SMO algorithm will move the Lagrangian multiplier to the end
of the line segment that can maximise the objective function.<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> <a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>Another simple way to handle this is to treat the scenario as no
progress being made for this pair of <span
class="math inline">\(\alpha\)</span>.</p>
<h3 id="comupting-the-threshold-b">Comupting the Threshold b</h3>
<p>We can update the threshold <span class="math inline">\(b\)</span>
after getting <span class="math inline">\(\alpha\)</span> at each
step.</p>
<p>When <span class="math inline">\(0 \lt \alpha_1 \lt C\)</span>, <span
class="math inline">\(b_1\)</span> is a valid threshold because it makes
the output <span class="math inline">\(\hat{y_1}\)</span> be the same as
<span class="math inline">\(y_1\)</span> when the input is <span
class="math inline">\(x_1\)</span></p>
<p><span class="math display">\[
E_1 = (y_1 \alpha^{old}_1 K_{11} + y_2 \alpha^{old}_2 K_{12} + b) - (y_1
\alpha^{new}_1 K_{11} + y_2 \alpha^{new}_2 K_{12} + b_1)
\]</span></p>
<p><span class="math display">\[
\Rightarrow b_1 = b - E_1 - y_1 (\alpha^{new}_1 - \alpha^{old}_1) K_{11}
- y_2 (\alpha^{new}_2  - \alpha^{old}_2) K_{12}
\]</span></p>
<p>Similarly, when <span class="math inline">\(\alpha_2\)</span> is not
at bounds, <span class="math inline">\(b_2\)</span> is a valid
threshold</p>
<p><span class="math display">\[
b_2 = b - E_2 - y_1 (\alpha^{new}_1 - \alpha^{old}_1) K_{12} - y_2
(\alpha^{new}_2  - \alpha^{old}_2) K_{22}
\]</span></p>
<p>When both <span class="math inline">\(b_1\)</span> and <span
class="math inline">\(b_2\)</span> are valid, they will be equal because
<span class="math inline">\(\hat{y_i} y_i = 1\)</span>, and the new
<span class="math inline">\(E_1\)</span> and <span
class="math inline">\(E_2\)</span> will be 0. This can be easily
verified with <span class="math inline">\((6)\)</span> and <span
class="math inline">\((7)\)</span>. Intuitively, when <span
class="math inline">\(y_1 = y_2\)</span>, they are both at bounds and is
trivial, whereas for <span class="math inline">\(y_1 \neq y_2\)</span>,
they both try to maximise the margin width, and this results in <span
class="math inline">\(b_1\)</span> and <span
class="math inline">\(b_2\)</span> being equal.</p>
<p>For other cases, we could choose the halfway between <span
class="math inline">\(b_1\)</span> and <span
class="math inline">\(b_2\)</span>.</p>

$$
  b=\begin{cases}
    b_1, & \text{if $0 \lt \alpha^{new}_1 \lt C$}.\\
    b_2, & \text{if $0 \lt \alpha^{new}_2 \lt C$}.\\
    \frac{(b_1+b_2)}{2}, & \text{otherwise}.
  \end{cases}
$$

<h3 id="choosing-the-multipliers-to-optimise">Choosing the Multipliers
to Optimise</h3>
<p>In order to speed up the training rate, the main idea of choosing the
multipliers in SMO can be briefly summarised as the following.</p>
<blockquote>
<p>Firstly, choose the multiplier that are likely to violate the KKT
conditions to optimise, i.e. <span class="math inline">\(0 &lt; \alpha_i
&lt; C\)</span>. When one multiplier is chosen, another multiplier would
be the one that can maximise the step size, <span
class="math inline">\(\vert E_2 - E_1 \vert\)</span>.</p>
</blockquote>
<p>Then SMO will scan the entire data sets until the algorithm
terminates.</p>
<h3 id="other-tricks-to-make-the-training-process-faster">Other Tricks
to Make the Training Process Faster</h3>
<h4 id="error-cache-update">Error Cache Update</h4>
<p>We can reduce the computational cost to compute the error cache,
which stores <span class="math inline">\(E_i\)</span>, after Lagrangian
multipliers update. From <span class="math inline">\((6)\)</span>,</p>
<p><span class="math display">\[
E^{old}_i = y_1 \alpha^{old}_1 K_{1i} + y_2 \alpha^{old} K_{2i} +
\sum^N_{j=3} y_j \alpha_j K_{ij} + b - y_i
\]</span></p>
<p><span class="math display">\[
E^{new}_i = y_1 \alpha^{new}_1 K_{1i} + y_2 \alpha^{new} K_{2i} +
\sum^N_{j=3} y_j \alpha_j K_{ij} + b_{new} - y_i
\]</span></p>
<p><span class="math display">\[
\Rightarrow E^{new}_i = E^{old}_i + y_1 (\alpha^{new}_1 -
\alpha^{old}_1) K_{1i} + y_2 (\alpha^{new}_2 - \alpha^{old}_2) K_{2i} +
(b_{new} - b)
\]</span></p>
<h4 id="linear-svm-optimisation">Linear SVM Optimisation</h4>
<p>The linear SVM only needs to store a single weight vector, <span
class="math inline">\(w\)</span>. It can also be updated using similar
mechanism as error cache. From <span
class="math inline">\((2)\)</span>,</p>
<p><span class="math display">\[
w^{old} = y_1 \alpha^{old}_1 x_1 + y_2 \alpha^{old}_2 x_2 + \sum^N_{j=3}
\alpha_j x_j
\]</span></p>
<p><span class="math display">\[
w^{new} = y_1 \alpha^{new}_1 x_1 + y_2 \alpha^{new}_2 x_2 + \sum^N_{j=3}
\alpha_j x_j
\]</span></p>
<p><span class="math display">\[
\Rightarrow w^{new} = w^{old} + y_1 (\alpha^{new}_1 - \alpha^{old}_1)
x_1 + y_2 (\alpha^{new}_2 - \alpha^{old}_2) x_2
\]</span></p>
<h2 id="implementation">Implementation</h2>
<h3 id="source-code">Source Code</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># File: MySVM.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SVM</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, X, y, C=<span class="number">1</span>, kernel=<span class="string">&#x27;linear&#x27;</span>, b=<span class="number">0</span>, max_iter=<span class="number">300</span>, tol=<span class="number">1e-5</span>, eps=<span class="number">1e-8</span></span>):</span></span><br><span class="line">        self.X = X</span><br><span class="line">        self.y = y</span><br><span class="line">        self.m, self.n = np.shape(self.X)</span><br><span class="line">        self.C = C</span><br><span class="line"></span><br><span class="line">        self.alphas = np.zeros(self.m)</span><br><span class="line">        self.b = b</span><br><span class="line"></span><br><span class="line">        self.kernel = kernel       <span class="comment"># &#x27;linear&#x27;, &#x27;rbf&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> kernel == <span class="string">&#x27;linear&#x27;</span>:</span><br><span class="line">            self.kernel_func = self.linear_kernel</span><br><span class="line">        <span class="keyword">elif</span> kernel == <span class="string">&#x27;gaussian&#x27;</span> <span class="keyword">or</span> kernel == <span class="string">&#x27;rbf&#x27;</span>:</span><br><span class="line">            self.kernel_func = self.gaussian_kernel</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;unknown kernel type&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.error = np.zeros(self.m)</span><br><span class="line"></span><br><span class="line">        self.max_iter=max_iter</span><br><span class="line">        self.tol = tol</span><br><span class="line">        self.eps = eps</span><br><span class="line"></span><br><span class="line">        self.is_linear_kernel = <span class="literal">True</span> <span class="keyword">if</span> self.kernel == <span class="string">&#x27;linear&#x27;</span> <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">        self.w = np.zeros(self.n)  <span class="comment"># used by linear kernel</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">linear_kernel</span>(<span class="params">self, x1, x2, b=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> x1 @ x2.T + b</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gaussian_kernel</span>(<span class="params">self, x1, x2, sigma=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> np.ndim(x1) == <span class="number">1</span> <span class="keyword">and</span> np.ndim(x2) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> np.exp(-(np.linalg.norm(x1-x2,<span class="number">2</span>))**<span class="number">2</span>/(<span class="number">2</span>*sigma**<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">elif</span>(np.ndim(x1)&gt;<span class="number">1</span> <span class="keyword">and</span> np.ndim(x2) == <span class="number">1</span>) <span class="keyword">or</span> (np.ndim(x1) == <span class="number">1</span> <span class="keyword">and</span> np.ndim(x2)&gt;<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> np.exp(-(np.linalg.norm(x1-x2, <span class="number">2</span>, axis=<span class="number">1</span>)**<span class="number">2</span>)/(<span class="number">2</span>*sigma**<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">elif</span> np.ndim(x1) &gt; <span class="number">1</span> <span class="keyword">and</span> np.ndim(x2) &gt; <span class="number">1</span> :</span><br><span class="line">            <span class="keyword">return</span> np.exp(-(np.linalg.norm(x1[:, np.newaxis] \</span><br><span class="line">                             - x2[np.newaxis, :], <span class="number">2</span>, axis = <span class="number">2</span>) ** <span class="number">2</span>)/(<span class="number">2</span>*sigma**<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        result = (self.alphas * self.y) @ self.kernel_func(self.X, x) + self.b</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_error</span>(<span class="params">self, i</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.predict(self.X[i,:]) - self.y[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">take_step</span>(<span class="params">self, i1, i2</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (i1 == i2):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        x1 = self.X[i1, :]</span><br><span class="line">        x2 = self.X[i2, :]</span><br><span class="line"></span><br><span class="line">        y1 = self.y[i1]</span><br><span class="line">        y2 = self.y[i2]</span><br><span class="line"></span><br><span class="line">        alpha1 = self.alphas[i1]</span><br><span class="line">        alpha2 = self.alphas[i2]</span><br><span class="line"></span><br><span class="line">        b = self.b</span><br><span class="line"></span><br><span class="line">        E1 = self.get_error(i1)</span><br><span class="line">        E2 = self.get_error(i2)</span><br><span class="line"></span><br><span class="line">        s = y1 * y2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> y1 != y2:</span><br><span class="line">            L = <span class="built_in">max</span>(<span class="number">0</span>, alpha2 - alpha1)</span><br><span class="line">            H = <span class="built_in">min</span>(self.C, self.C + alpha2 - alpha1)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            L = <span class="built_in">max</span>(<span class="number">0</span>, alpha2 + alpha1 - self.C)</span><br><span class="line">            H = <span class="built_in">min</span>(self.C, alpha2 + alpha1)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> L == H:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        k11 = self.kernel_func(x1, x1)</span><br><span class="line">        k12 = self.kernel_func(x1, x2)</span><br><span class="line">        k22 = self.kernel_func(x2, x2)</span><br><span class="line"></span><br><span class="line">        eta = k11 + k22 - <span class="number">2</span> * k12</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> eta &gt; <span class="number">0</span>:</span><br><span class="line">            alpha2_new = alpha2 + y2 * (E1 - E2) / eta</span><br><span class="line">            <span class="keyword">if</span> alpha2_new &gt;= H:</span><br><span class="line">                alpha2_new = H</span><br><span class="line">            <span class="keyword">elif</span> alpha2_new &lt;= L:</span><br><span class="line">                alpha2_new = L</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Abnormal case for eta &lt;= 0, treat this scenario as no progress</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Numerical tolerance</span></span><br><span class="line">        <span class="comment"># if abs(alpha2_new - alpha2) &lt; self.eps:   # this is slower</span></span><br><span class="line">        <span class="comment"># below is faster, not degrade the SVM performance</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(alpha2_new - alpha2) &lt; self.eps * (alpha2 + alpha2_new + self.eps):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        alpha1_new = alpha1 + s * (alpha2 - alpha2_new)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Numerical tolerance</span></span><br><span class="line">        <span class="keyword">if</span> alpha1_new &lt; self.eps:</span><br><span class="line">            alpha1_new = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> alpha1_new &gt; (self.C - self.eps):</span><br><span class="line">            alpha1_new = self.C</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Update threshold</span></span><br><span class="line">        b1 = b - E1 - y1 * (alpha1_new - alpha1) * k11 - y2 * (alpha2_new - alpha2) * k12</span><br><span class="line">        b2 = b - E2 - y1 * (alpha1_new - alpha1) * k12 - y2 * (alpha2_new - alpha2) * k22</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt; alpha1_new &lt; self.C:</span><br><span class="line">            self.b = b1</span><br><span class="line">        <span class="keyword">elif</span> <span class="number">0</span> &lt; alpha2_new &lt; self.C:</span><br><span class="line">            self.b = b2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.b = <span class="number">0.5</span> * (b1 + b2)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Update weight vector for linear SVM</span></span><br><span class="line">        <span class="keyword">if</span> self.is_linear_kernel:</span><br><span class="line">            self.w = self.w + y1 * (alpha1_new - alpha1) * x1 \</span><br><span class="line">                            + y2 * (alpha2_new - alpha2) * x2</span><br><span class="line"></span><br><span class="line">        self.alphas[i1] = alpha1_new</span><br><span class="line">        self.alphas[i2] = alpha2_new</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Error cache update</span></span><br><span class="line">        <span class="comment">## if alpha1 &amp; alpha2 are not at bounds, the error will be 0</span></span><br><span class="line">        self.error[i1] = <span class="number">0</span></span><br><span class="line">        self.error[i2] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        i_list = [idx <span class="keyword">for</span> idx, alpha <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.alphas) \</span><br><span class="line">                      <span class="keyword">if</span> <span class="number">0</span> &lt; alpha <span class="keyword">and</span> alpha &lt; self.C]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> i_list:</span><br><span class="line">            self.error[i] += \</span><br><span class="line">                  y1 * (alpha1_new - alpha1) * self.kernel_func(x1, self.X[i,:]) \</span><br><span class="line">                + y2 * (alpha2_new - alpha2) * self.kernel_func(x2, self.X[i,:]) \</span><br><span class="line">                + (self.b - b)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">examine_example</span>(<span class="params">self, i2</span>):</span></span><br><span class="line">        y2 = self.y[i2]</span><br><span class="line">        alpha2 = self.alphas[i2]</span><br><span class="line">        E2 = self.get_error(i2)</span><br><span class="line">        r2 = E2 * y2</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Choose the one that is likely to violiate KKT</span></span><br><span class="line">        <span class="comment"># if (0 &lt; alpha2 &lt; self.C) or (abs(r2) &gt; self.tol):  # this is slow</span></span><br><span class="line">        <span class="comment"># below is faster, not degrade the SVM performance</span></span><br><span class="line">        <span class="keyword">if</span> ((r2 &lt; -self.tol <span class="keyword">and</span> alpha2 &lt; self.C) <span class="keyword">or</span> (r2 &gt; self.tol <span class="keyword">and</span> alpha2 &gt; <span class="number">0</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.alphas[(<span class="number">0</span> &lt; self.alphas) &amp; (self.alphas &lt; self.C)]) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> E2 &gt; <span class="number">0</span>:</span><br><span class="line">                    i1 = np.argmin(self.error)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i1 = np.argmax(self.error)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> self.take_step(i1, i2):</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># loop over all non-zero and non-C alpha, starting at a random point</span></span><br><span class="line">            i1_list = [idx <span class="keyword">for</span> idx, alpha <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.alphas) \</span><br><span class="line">                           <span class="keyword">if</span> <span class="number">0</span> &lt; alpha <span class="keyword">and</span> alpha &lt; self.C]</span><br><span class="line">            i1_list = np.roll(i1_list, np.random.choice(np.arange(self.m)))</span><br><span class="line">            <span class="keyword">for</span> i1 <span class="keyword">in</span> i1_list:</span><br><span class="line">                <span class="keyword">if</span> self.take_step(i1, i2):</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># loop over all possible i1, starting at a random point</span></span><br><span class="line">            i1_list = np.roll(np.arange(self.m), np.random.choice(np.arange(self.m)))</span><br><span class="line">            <span class="keyword">for</span> i1 <span class="keyword">in</span> i1_list:</span><br><span class="line">                <span class="keyword">if</span> self.take_step(i1, i2):</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span>(<span class="params">self</span>):</span></span><br><span class="line">        loop_num = <span class="number">0</span></span><br><span class="line">        numChanged = <span class="number">0</span></span><br><span class="line">        examineAll = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> numChanged &gt; <span class="number">0</span> <span class="keyword">or</span> examineAll:</span><br><span class="line">            <span class="keyword">if</span> loop_num &gt;= self.max_iter:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            numChanged = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> examineAll:</span><br><span class="line">                <span class="keyword">for</span> i2 <span class="keyword">in</span> <span class="built_in">range</span>(self.m):</span><br><span class="line">                    numChanged += self.examine_example(i2)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i2_list = [idx <span class="keyword">for</span> idx, alpha <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.alphas) \</span><br><span class="line">                                <span class="keyword">if</span> <span class="number">0</span> &lt; alpha <span class="keyword">and</span> alpha &lt; self.C]</span><br><span class="line">                <span class="keyword">for</span> i2 <span class="keyword">in</span> i2_list:</span><br><span class="line">                    numChanged += self.examine_example(i2)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> examineAll:</span><br><span class="line">                examineAll = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> numChanged == <span class="number">0</span>:</span><br><span class="line">                examineAll = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            loop_num += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="demo">Demo</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># File: SVM_test.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> MySVM</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_circle</span>(<span class="params">n=<span class="number">50</span>, center_x=<span class="number">0</span>, center_y=<span class="number">0</span>, radius=<span class="number">1</span>, label=<span class="number">0</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    A simple function that generates circular distribution</span></span><br><span class="line"><span class="string">    n: number of points (default=50)</span></span><br><span class="line"><span class="string">    center_x: the center for X (default=0)</span></span><br><span class="line"><span class="string">    center_y: the center for Y (default=0)</span></span><br><span class="line"><span class="string">    radius: the radius of circle (default=1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># random angle</span></span><br><span class="line">    alpha = <span class="number">2</span> * np.pi * np.random.rand(n)</span><br><span class="line">    <span class="comment"># random radius</span></span><br><span class="line">    r = radius * np.sqrt(np.random.rand(n))</span><br><span class="line">    <span class="comment"># calculating coordinates</span></span><br><span class="line">    x = r * np.cos(alpha) + center_x</span><br><span class="line">    y = r * np.sin(alpha) + center_y</span><br><span class="line"></span><br><span class="line">    label = np.ones(n) * label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [x, y, label]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    np.random.seed(<span class="number">5</span>)   <span class="comment"># to reproduce</span></span><br><span class="line"></span><br><span class="line">    n = <span class="number">100</span></span><br><span class="line">    C0 = gen_circle(n, center_x=<span class="number">1</span>, center_y=<span class="number">1</span>, radius=<span class="number">1.05</span>, label=<span class="number">1</span>)</span><br><span class="line">    C1 = gen_circle(n, center_x=-<span class="number">1</span>, center_y=-<span class="number">1</span>, radius=<span class="number">1.05</span>, label=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    x0 = np.append(C0[<span class="number">0</span>], C1[<span class="number">0</span>])</span><br><span class="line">    x1 = np.append(C0[<span class="number">1</span>], C1[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    X = np.c_[x0, x1]</span><br><span class="line">    Y = np.append(C0[<span class="number">2</span>], C1[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    scaler = StandardScaler()</span><br><span class="line">    train_x = scaler.fit_transform(X)</span><br><span class="line"></span><br><span class="line">    model = MySVM.SVM(train_x, Y, C=<span class="number">1</span>, kernel=<span class="string">&#x27;linear&#x27;</span>, max_iter=<span class="number">600</span>, tol=<span class="number">1e-5</span>, eps=<span class="number">1e-5</span>)</span><br><span class="line">    <span class="comment"># model = MySVM.SVM(train_x, Y, C=1, kernel=&#x27;rbf&#x27;, max_iter=600, tol=1e-5, eps=1e-5)</span></span><br><span class="line">    model.fit()</span><br><span class="line"></span><br><span class="line">    train_y = model.predict(train_x)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;support vector: &#123;&#125; / &#123;&#125;&#x27;</span>\</span><br><span class="line">        .<span class="built_in">format</span>(<span class="built_in">len</span>(model.alphas[model.alphas != <span class="number">0</span>]), <span class="built_in">len</span>(model.alphas)))</span><br><span class="line">    sv_idx = []</span><br><span class="line">    <span class="keyword">for</span> idx, alpha <span class="keyword">in</span> <span class="built_in">enumerate</span>(model.alphas):</span><br><span class="line">        <span class="keyword">if</span> alpha != <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;index = &#123;&#125;, alpha = &#123;:.3f&#125;, predict y=&#123;:.3f&#125;&#x27;</span>\</span><br><span class="line">                .<span class="built_in">format</span>(idx, alpha, train_y[idx]))</span><br><span class="line">            sv_idx.append(idx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;bias = <span class="subst">&#123;model.b&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;training data error rate = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(Y[Y * train_y &lt; <span class="number">0</span>])/<span class="built_in">len</span>(Y)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">## Draw the Plot</span></span><br><span class="line">    plt.plot(C0[<span class="number">0</span>], C0[<span class="number">1</span>], <span class="string">&#x27;o&#x27;</span>, markerfacecolor=<span class="string">&#x27;r&#x27;</span>, markeredgecolor=<span class="string">&#x27;None&#x27;</span>, alpha=<span class="number">0.55</span>)</span><br><span class="line">    plt.plot(C1[<span class="number">0</span>], C1[<span class="number">1</span>], <span class="string">&#x27;o&#x27;</span>, markerfacecolor=<span class="string">&#x27;b&#x27;</span>, markeredgecolor=<span class="string">&#x27;None&#x27;</span>, alpha=<span class="number">0.55</span>)</span><br><span class="line"></span><br><span class="line">    resolution = <span class="number">50</span></span><br><span class="line">    dx = np.linspace(X[:, <span class="number">0</span>].<span class="built_in">min</span>(), X[:, <span class="number">0</span>].<span class="built_in">max</span>(), resolution)</span><br><span class="line">    dy = np.linspace(X[:, <span class="number">1</span>].<span class="built_in">min</span>(), X[:, <span class="number">1</span>].<span class="built_in">max</span>(), resolution)</span><br><span class="line">    dx, dy = np.meshgrid(dx, dy)</span><br><span class="line">    plot_x = np.c_[dx.flatten(), dy.flatten()]</span><br><span class="line"></span><br><span class="line">    dz = model.predict(scaler.transform(plot_x))</span><br><span class="line">    dz = dz.reshape(dx.shape)</span><br><span class="line"></span><br><span class="line">    plt.contour(dx, dy, dz, alpha=<span class="number">1</span>, colors=(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;r&#x27;</span>), \</span><br><span class="line">                levels=(-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), linestyles = (<span class="string">&#x27;--&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;--&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    label_cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> sv_idx:</span><br><span class="line">        <span class="keyword">if</span> label_cnt == <span class="number">0</span>:</span><br><span class="line">            plt.scatter(X[i, <span class="number">0</span>], X[i, <span class="number">1</span>], marker=<span class="string">&#x27;*&#x27;</span>, color=<span class="string">&#x27;k&#x27;</span>, \</span><br><span class="line">                        s=<span class="number">120</span>, label=<span class="string">&#x27;Support vector&#x27;</span>)</span><br><span class="line">            label_cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        plt.scatter(X[i, <span class="number">0</span>], X[i, <span class="number">1</span>], marker=<span class="string">&#x27;*&#x27;</span>, color=<span class="string">&#x27;k&#x27;</span>, s=<span class="number">120</span>)</span><br><span class="line"></span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<img src="/2022/07/30/Implement-SVM-with-SMO-from-scratch/svm_5.png" class="" title="Figure 5">
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-98-14.pdf">Sequential
Minimal Optimization: A Fast Algorithm for Training Support Vector
Machines</a><a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a
href="https://www.cs.mcgill.ca/~hv/publications/99.04.McGill.thesis.gmak.pdf">The
implementation of Support Vector Machines using the sequential minimal
optimization algorithm</a><a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>Mathematics</category>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Optimisation</tag>
        <tag>Kernel Method</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Ubuntu] 開機畫面卡在 /dev/sda*: clean, */* files </title>
    <url>/2023/08/12/ubuntu-bootup-problem-nvidia-dev-sda-clean/</url>
    <content><![CDATA[<p>有時候開機會莫名出現以下相關的訊息後就卡住了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/sda*: clean, *******/******* files</span><br></pre></td></tr></table></figure>
<p>排查了一下發現問題常常是出在 Nvidia 的 driver 沒有正確被啟動</p>
<span id="more"></span>
<h2 id="enable-bootup-verbose-mode-from-grub">Enable Bootup Verbose Mode
from GRUB</h2>
<p>首先在開機時要能夠顯示更加詳細的訊息來除錯</p>
<p>修改 <code>/etc/default/grub</code> 這支file</p>
<p>預設模式是 <code>quiet splash</code></p>
<p>一般來說改為空字串就足夠定位出錯誤發生的地方</p>
<p>使用 <code>--verbose nosplash debug</code> 則可以顯示更多開機細節</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">#GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;</span></span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># more log from upstart</span></span><br><span class="line"><span class="comment">#GRUB_CMDLINE_LINUX_DEFAULT=&quot;--verbose nosplash debug&quot;</span></span><br></pre></td></tr></table></figure>
<p>更改完後要記得更新 GRUB 的設定 並重開機</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-grub</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<p>從 Bootup Log 裡可以確認出 Nvidia service
有問題導致無法順利正常開機</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">[FAILED] Failed to start NVIDIA Persistence.</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="重新安裝-nvidia-driver">重新安裝 Nvidia driver</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt purge nvidia*    <span class="comment"># remove nvidia* packages</span></span><br><span class="line">sudo ubuntu-drivers autoinstall</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<p><code>autoinstall</code> 會自動幫你找到適合的下載版本</p>
<p>如果找不到可以再自行去 <a
href="https://www.nvidia.com/Download/index.aspx?lang=en-us">Nvidia
Download Drivers 官網</a> 來安裝需要的版本</p>
]]></content>
      <categories>
        <category>Environment SetUp</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
</search>
